// Code generated by protoc-gen-go.
// source: MurmurRPC.proto
// DO NOT EDIT!

/*
Package MurmurRPC is a generated protocol buffer package.

It is generated from these files:
	MurmurRPC.proto

It has these top-level messages:
	Void
	Version
	Uptime
	Server
	Event
	ContextAction
	TextMessage
	Log
	Config
	Channel
	User
	Tree
	Ban
	ACL
	Authenticator
	DatabaseUser
	RedirectWhisperGroup
*/
package MurmurRPC

import proto "github.com/golang/protobuf/proto"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type Server_Event_Type int32

const (
	Server_Event_UserConnected       Server_Event_Type = 0
	Server_Event_UserDisconnected    Server_Event_Type = 1
	Server_Event_UserStateChanged    Server_Event_Type = 2
	Server_Event_UserTextMessage     Server_Event_Type = 3
	Server_Event_ChannelCreated      Server_Event_Type = 4
	Server_Event_ChannelRemoved      Server_Event_Type = 5
	Server_Event_ChannelStateChanged Server_Event_Type = 6
)

var Server_Event_Type_name = map[int32]string{
	0: "UserConnected",
	1: "UserDisconnected",
	2: "UserStateChanged",
	3: "UserTextMessage",
	4: "ChannelCreated",
	5: "ChannelRemoved",
	6: "ChannelStateChanged",
}
var Server_Event_Type_value = map[string]int32{
	"UserConnected":       0,
	"UserDisconnected":    1,
	"UserStateChanged":    2,
	"UserTextMessage":     3,
	"ChannelCreated":      4,
	"ChannelRemoved":      5,
	"ChannelStateChanged": 6,
}

func (x Server_Event_Type) Enum() *Server_Event_Type {
	p := new(Server_Event_Type)
	*p = x
	return p
}
func (x Server_Event_Type) String() string {
	return proto.EnumName(Server_Event_Type_name, int32(x))
}
func (x *Server_Event_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Server_Event_Type_value, data, "Server_Event_Type")
	if err != nil {
		return err
	}
	*x = Server_Event_Type(value)
	return nil
}

type Event_Type int32

const (
	Event_ServerStarted Event_Type = 0
	Event_ServerStopped Event_Type = 1
)

var Event_Type_name = map[int32]string{
	0: "ServerStarted",
	1: "ServerStopped",
}
var Event_Type_value = map[string]int32{
	"ServerStarted": 0,
	"ServerStopped": 1,
}

func (x Event_Type) Enum() *Event_Type {
	p := new(Event_Type)
	*p = x
	return p
}
func (x Event_Type) String() string {
	return proto.EnumName(Event_Type_name, int32(x))
}
func (x *Event_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Event_Type_value, data, "Event_Type")
	if err != nil {
		return err
	}
	*x = Event_Type(value)
	return nil
}

type ContextAction_Context int32

const (
	ContextAction_None    ContextAction_Context = 0
	ContextAction_Server  ContextAction_Context = 1
	ContextAction_Channel ContextAction_Context = 2
	ContextAction_User    ContextAction_Context = 4
)

var ContextAction_Context_name = map[int32]string{
	0: "None",
	1: "Server",
	2: "Channel",
	4: "User",
}
var ContextAction_Context_value = map[string]int32{
	"None":    0,
	"Server":  1,
	"Channel": 2,
	"User":    4,
}

func (x ContextAction_Context) Enum() *ContextAction_Context {
	p := new(ContextAction_Context)
	*p = x
	return p
}
func (x ContextAction_Context) String() string {
	return proto.EnumName(ContextAction_Context_name, int32(x))
}
func (x *ContextAction_Context) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ContextAction_Context_value, data, "ContextAction_Context")
	if err != nil {
		return err
	}
	*x = ContextAction_Context(value)
	return nil
}

type ACL_Permission int32

const (
	ACL_None                 ACL_Permission = 0
	ACL_Write                ACL_Permission = 1
	ACL_Traverse             ACL_Permission = 2
	ACL_Enter                ACL_Permission = 4
	ACL_Speak                ACL_Permission = 8
	ACL_Whisper              ACL_Permission = 256
	ACL_MuteDeafen           ACL_Permission = 16
	ACL_Move                 ACL_Permission = 32
	ACL_MakeChannel          ACL_Permission = 64
	ACL_MakeTemporaryChannel ACL_Permission = 1024
	ACL_LinkChannel          ACL_Permission = 128
	ACL_TextMessage          ACL_Permission = 512
	ACL_Kick                 ACL_Permission = 65536
	ACL_Ban                  ACL_Permission = 131072
	ACL_Register             ACL_Permission = 262144
	ACL_RegisterSelf         ACL_Permission = 524288
)

var ACL_Permission_name = map[int32]string{
	0:      "None",
	1:      "Write",
	2:      "Traverse",
	4:      "Enter",
	8:      "Speak",
	256:    "Whisper",
	16:     "MuteDeafen",
	32:     "Move",
	64:     "MakeChannel",
	1024:   "MakeTemporaryChannel",
	128:    "LinkChannel",
	512:    "TextMessage",
	65536:  "Kick",
	131072: "Ban",
	262144: "Register",
	524288: "RegisterSelf",
}
var ACL_Permission_value = map[string]int32{
	"None":                 0,
	"Write":                1,
	"Traverse":             2,
	"Enter":                4,
	"Speak":                8,
	"Whisper":              256,
	"MuteDeafen":           16,
	"Move":                 32,
	"MakeChannel":          64,
	"MakeTemporaryChannel": 1024,
	"LinkChannel":          128,
	"TextMessage":          512,
	"Kick":                 65536,
	"Ban":                  131072,
	"Register":             262144,
	"RegisterSelf":         524288,
}

func (x ACL_Permission) Enum() *ACL_Permission {
	p := new(ACL_Permission)
	*p = x
	return p
}
func (x ACL_Permission) String() string {
	return proto.EnumName(ACL_Permission_name, int32(x))
}
func (x *ACL_Permission) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ACL_Permission_value, data, "ACL_Permission")
	if err != nil {
		return err
	}
	*x = ACL_Permission(value)
	return nil
}

type Authenticator_Message_Type int32

const (
	Authenticator_Message_Initialize                   Authenticator_Message_Type = 0
	Authenticator_Message_Authenticate                 Authenticator_Message_Type = 1
	Authenticator_Message_AuthenticateTemporaryFailure Authenticator_Message_Type = 2
	Authenticator_Message_AuthenticateFailure          Authenticator_Message_Type = 3
	Authenticator_Message_Information                  Authenticator_Message_Type = 4
	// Below types are only sent when "registrationStream" used.
	Authenticator_Message_Register   Authenticator_Message_Type = 5
	Authenticator_Message_Unregister Authenticator_Message_Type = 6
	Authenticator_Message_Update     Authenticator_Message_Type = 7
	Authenticator_Message_Query      Authenticator_Message_Type = 8
)

var Authenticator_Message_Type_name = map[int32]string{
	0: "Initialize",
	1: "Authenticate",
	2: "AuthenticateTemporaryFailure",
	3: "AuthenticateFailure",
	4: "Information",
	5: "Register",
	6: "Unregister",
	7: "Update",
	8: "Query",
}
var Authenticator_Message_Type_value = map[string]int32{
	"Initialize":                   0,
	"Authenticate":                 1,
	"AuthenticateTemporaryFailure": 2,
	"AuthenticateFailure":          3,
	"Information":                  4,
	"Register":                     5,
	"Unregister":                   6,
	"Update":                       7,
	"Query":                        8,
}

func (x Authenticator_Message_Type) Enum() *Authenticator_Message_Type {
	p := new(Authenticator_Message_Type)
	*p = x
	return p
}
func (x Authenticator_Message_Type) String() string {
	return proto.EnumName(Authenticator_Message_Type_name, int32(x))
}
func (x *Authenticator_Message_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Authenticator_Message_Type_value, data, "Authenticator_Message_Type")
	if err != nil {
		return err
	}
	*x = Authenticator_Message_Type(value)
	return nil
}

type Void struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Void) Reset()         { *m = Void{} }
func (m *Void) String() string { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()    {}

type Version struct {
	// 2-byte Major, 1-byte Minor and 1-byte Patch version number.
	Version *uint32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	// Client release name.
	Release *string `protobuf:"bytes,2,opt,name=release" json:"release,omitempty"`
	// Client OS name.
	Os *string `protobuf:"bytes,3,opt,name=os" json:"os,omitempty"`
	// Client OS version.
	OsVersion        *string `protobuf:"bytes,4,opt,name=os_version" json:"os_version,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Version) Reset()         { *m = Version{} }
func (m *Version) String() string { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()    {}

func (m *Version) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *Version) GetRelease() string {
	if m != nil && m.Release != nil {
		return *m.Release
	}
	return ""
}

func (m *Version) GetOs() string {
	if m != nil && m.Os != nil {
		return *m.Os
	}
	return ""
}

func (m *Version) GetOsVersion() string {
	if m != nil && m.OsVersion != nil {
		return *m.OsVersion
	}
	return ""
}

type Uptime struct {
	Secs             *uint64 `protobuf:"varint,1,opt,name=secs" json:"secs,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Uptime) Reset()         { *m = Uptime{} }
func (m *Uptime) String() string { return proto.CompactTextString(m) }
func (*Uptime) ProtoMessage()    {}

func (m *Uptime) GetSecs() uint64 {
	if m != nil && m.Secs != nil {
		return *m.Secs
	}
	return 0
}

type Server struct {
	Id               *uint32 `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
	Running          *bool   `protobuf:"varint,2,opt,name=running" json:"running,omitempty"`
	Uptime           *uint32 `protobuf:"varint,3,opt,name=uptime" json:"uptime,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Server) Reset()         { *m = Server{} }
func (m *Server) String() string { return proto.CompactTextString(m) }
func (*Server) ProtoMessage()    {}

func (m *Server) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Server) GetRunning() bool {
	if m != nil && m.Running != nil {
		return *m.Running
	}
	return false
}

func (m *Server) GetUptime() uint32 {
	if m != nil && m.Uptime != nil {
		return *m.Uptime
	}
	return 0
}

type Server_Event struct {
	Server           *Server            `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	Type             *Server_Event_Type `protobuf:"varint,2,opt,name=type,enum=MurmurRPC.Server_Event_Type" json:"type,omitempty"`
	User             *User              `protobuf:"bytes,3,opt,name=user" json:"user,omitempty"`
	Message          *TextMessage       `protobuf:"bytes,4,opt,name=message" json:"message,omitempty"`
	Channel          *Channel           `protobuf:"bytes,5,opt,name=channel" json:"channel,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *Server_Event) Reset()         { *m = Server_Event{} }
func (m *Server_Event) String() string { return proto.CompactTextString(m) }
func (*Server_Event) ProtoMessage()    {}

func (m *Server_Event) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Server_Event) GetType() Server_Event_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Server_Event_UserConnected
}

func (m *Server_Event) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Server_Event) GetMessage() *TextMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Server_Event) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

type Server_Query struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Server_Query) Reset()         { *m = Server_Query{} }
func (m *Server_Query) String() string { return proto.CompactTextString(m) }
func (*Server_Query) ProtoMessage()    {}

type Server_List struct {
	Servers          []*Server `protobuf:"bytes,1,rep,name=servers" json:"servers,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Server_List) Reset()         { *m = Server_List{} }
func (m *Server_List) String() string { return proto.CompactTextString(m) }
func (*Server_List) ProtoMessage()    {}

func (m *Server_List) GetServers() []*Server {
	if m != nil {
		return m.Servers
	}
	return nil
}

type Event struct {
	Type             *Event_Type `protobuf:"varint,1,opt,name=type,enum=MurmurRPC.Event_Type" json:"type,omitempty"`
	Server           *Server     `protobuf:"bytes,2,opt,name=server" json:"server,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}

func (m *Event) GetType() Event_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Event_ServerStarted
}

func (m *Event) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

type ContextAction struct {
	Server           *Server                `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	Context          *ContextAction_Context `protobuf:"varint,2,opt,name=context,enum=MurmurRPC.ContextAction_Context" json:"context,omitempty"`
	Action           *string                `protobuf:"bytes,3,opt,name=action" json:"action,omitempty"`
	Text             *string                `protobuf:"bytes,4,opt,name=text" json:"text,omitempty"`
	Actor            *User                  `protobuf:"bytes,5,opt,name=actor" json:"actor,omitempty"`
	User             *User                  `protobuf:"bytes,6,opt,name=user" json:"user,omitempty"`
	Channel          *Channel               `protobuf:"bytes,7,opt,name=channel" json:"channel,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *ContextAction) Reset()         { *m = ContextAction{} }
func (m *ContextAction) String() string { return proto.CompactTextString(m) }
func (*ContextAction) ProtoMessage()    {}

func (m *ContextAction) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *ContextAction) GetContext() ContextAction_Context {
	if m != nil && m.Context != nil {
		return *m.Context
	}
	return ContextAction_None
}

func (m *ContextAction) GetAction() string {
	if m != nil && m.Action != nil {
		return *m.Action
	}
	return ""
}

func (m *ContextAction) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

func (m *ContextAction) GetActor() *User {
	if m != nil {
		return m.Actor
	}
	return nil
}

func (m *ContextAction) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ContextAction) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

type TextMessage struct {
	Server           *Server    `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	Actor            *User      `protobuf:"bytes,2,opt,name=actor" json:"actor,omitempty"`
	Users            []*User    `protobuf:"bytes,3,rep,name=users" json:"users,omitempty"`
	Channels         []*Channel `protobuf:"bytes,4,rep,name=channels" json:"channels,omitempty"`
	Trees            []*Channel `protobuf:"bytes,5,rep,name=trees" json:"trees,omitempty"`
	Text             *string    `protobuf:"bytes,6,opt,name=text" json:"text,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *TextMessage) Reset()         { *m = TextMessage{} }
func (m *TextMessage) String() string { return proto.CompactTextString(m) }
func (*TextMessage) ProtoMessage()    {}

func (m *TextMessage) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *TextMessage) GetActor() *User {
	if m != nil {
		return m.Actor
	}
	return nil
}

func (m *TextMessage) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *TextMessage) GetChannels() []*Channel {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *TextMessage) GetTrees() []*Channel {
	if m != nil {
		return m.Trees
	}
	return nil
}

func (m *TextMessage) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

type Log struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Log) Reset()         { *m = Log{} }
func (m *Log) String() string { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()    {}

type Log_Entry struct {
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	Timestamp        *int64  `protobuf:"varint,2,opt,name=timestamp" json:"timestamp,omitempty"`
	Text             *string `protobuf:"bytes,3,opt,name=text" json:"text,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Log_Entry) Reset()         { *m = Log_Entry{} }
func (m *Log_Entry) String() string { return proto.CompactTextString(m) }
func (*Log_Entry) ProtoMessage()    {}

func (m *Log_Entry) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Log_Entry) GetTimestamp() int64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *Log_Entry) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

type Log_Query struct {
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	StartTimestamp   *int64  `protobuf:"varint,2,opt,name=start_timestamp" json:"start_timestamp,omitempty"`
	EndTimestamp     *int64  `protobuf:"varint,3,opt,name=end_timestamp" json:"end_timestamp,omitempty"`
	Limit            *uint32 `protobuf:"varint,4,opt,name=limit" json:"limit,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Log_Query) Reset()         { *m = Log_Query{} }
func (m *Log_Query) String() string { return proto.CompactTextString(m) }
func (*Log_Query) ProtoMessage()    {}

func (m *Log_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Log_Query) GetStartTimestamp() int64 {
	if m != nil && m.StartTimestamp != nil {
		return *m.StartTimestamp
	}
	return 0
}

func (m *Log_Query) GetEndTimestamp() int64 {
	if m != nil && m.EndTimestamp != nil {
		return *m.EndTimestamp
	}
	return 0
}

func (m *Log_Query) GetLimit() uint32 {
	if m != nil && m.Limit != nil {
		return *m.Limit
	}
	return 0
}

// Having "Config" seems preferable to having a map (map<string, string>),
// since. we are able to get some type safety. The downside to this is that
// arbitrary config values cannot be set (i.e. a user cannot set the "county"
// config value without changing the protocol buffer on both the client and
// server).
type Config struct {
	Server              *Server  `protobuf:"bytes,55,opt,name=server" json:"server,omitempty"`
	Password            *string  `protobuf:"bytes,1,opt,name=password" json:"password,omitempty"`
	Timeout             *uint32  `protobuf:"varint,2,opt,name=timeout" json:"timeout,omitempty"`
	Bandwidth           *uint32  `protobuf:"varint,3,opt,name=bandwidth" json:"bandwidth,omitempty"`
	Users               *uint32  `protobuf:"varint,4,opt,name=users" json:"users,omitempty"`
	UsersPerChannel     *uint32  `protobuf:"varint,5,opt,name=users_per_channel" json:"users_per_channel,omitempty"`
	TextMessageLength   *uint32  `protobuf:"varint,6,opt,name=text_message_length" json:"text_message_length,omitempty"`
	ImageMessageLength  *uint32  `protobuf:"varint,7,opt,name=image_message_length" json:"image_message_length,omitempty"`
	AllowHelp           *bool    `protobuf:"varint,8,opt,name=allow_help" json:"allow_help,omitempty"`
	DefaultChannel      *Channel `protobuf:"bytes,9,opt,name=default_channel" json:"default_channel,omitempty"`
	RememberChannel     *bool    `protobuf:"varint,10,opt,name=remember_channel" json:"remember_channel,omitempty"`
	WelcomeText         *string  `protobuf:"bytes,11,opt,name=welcome_text" json:"welcome_text,omitempty"`
	RegisterName        *string  `protobuf:"bytes,12,opt,name=register_name" json:"register_name,omitempty"`
	RegisterPassword    *string  `protobuf:"bytes,13,opt,name=register_password" json:"register_password,omitempty"`
	RegisterHostname    *string  `protobuf:"bytes,14,opt,name=register_hostname" json:"register_hostname,omitempty"`
	RegisterLocation    *string  `protobuf:"bytes,15,opt,name=register_location" json:"register_location,omitempty"`
	RegisterUrl         *string  `protobuf:"bytes,16,opt,name=register_url" json:"register_url,omitempty"`
	CertRequired        *bool    `protobuf:"varint,17,opt,name=cert_required" json:"cert_required,omitempty"`
	ForceExternalAuth   *bool    `protobuf:"varint,18,opt,name=force_external_auth" json:"force_external_auth,omitempty"`
	Bonjour             *bool    `protobuf:"varint,19,opt,name=bonjour" json:"bonjour,omitempty"`
	AllowPing           *bool    `protobuf:"varint,20,opt,name=allow_ping" json:"allow_ping,omitempty"`
	Username            *string  `protobuf:"bytes,21,opt,name=username" json:"username,omitempty"`
	Channelname         *string  `protobuf:"bytes,22,opt,name=channelname" json:"channelname,omitempty"`
	SuggestVersion      *Version `protobuf:"bytes,23,opt,name=suggest_version" json:"suggest_version,omitempty"`
	SuggestPositional   *bool    `protobuf:"varint,24,opt,name=suggest_positional" json:"suggest_positional,omitempty"`
	SuggestPushToTalk   *bool    `protobuf:"varint,25,opt,name=suggest_push_to_talk" json:"suggest_push_to_talk,omitempty"`
	OpusThreshold       *uint32  `protobuf:"varint,26,opt,name=opus_threshold" json:"opus_threshold,omitempty"`
	ChannelNestingLimit *uint32  `protobuf:"varint,27,opt,name=channel_nesting_limit" json:"channel_nesting_limit,omitempty"`
	XXX_unrecognized    []byte   `json:"-"`
}

func (m *Config) Reset()         { *m = Config{} }
func (m *Config) String() string { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()    {}

func (m *Config) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Config) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *Config) GetTimeout() uint32 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return 0
}

func (m *Config) GetBandwidth() uint32 {
	if m != nil && m.Bandwidth != nil {
		return *m.Bandwidth
	}
	return 0
}

func (m *Config) GetUsers() uint32 {
	if m != nil && m.Users != nil {
		return *m.Users
	}
	return 0
}

func (m *Config) GetUsersPerChannel() uint32 {
	if m != nil && m.UsersPerChannel != nil {
		return *m.UsersPerChannel
	}
	return 0
}

func (m *Config) GetTextMessageLength() uint32 {
	if m != nil && m.TextMessageLength != nil {
		return *m.TextMessageLength
	}
	return 0
}

func (m *Config) GetImageMessageLength() uint32 {
	if m != nil && m.ImageMessageLength != nil {
		return *m.ImageMessageLength
	}
	return 0
}

func (m *Config) GetAllowHelp() bool {
	if m != nil && m.AllowHelp != nil {
		return *m.AllowHelp
	}
	return false
}

func (m *Config) GetDefaultChannel() *Channel {
	if m != nil {
		return m.DefaultChannel
	}
	return nil
}

func (m *Config) GetRememberChannel() bool {
	if m != nil && m.RememberChannel != nil {
		return *m.RememberChannel
	}
	return false
}

func (m *Config) GetWelcomeText() string {
	if m != nil && m.WelcomeText != nil {
		return *m.WelcomeText
	}
	return ""
}

func (m *Config) GetRegisterName() string {
	if m != nil && m.RegisterName != nil {
		return *m.RegisterName
	}
	return ""
}

func (m *Config) GetRegisterPassword() string {
	if m != nil && m.RegisterPassword != nil {
		return *m.RegisterPassword
	}
	return ""
}

func (m *Config) GetRegisterHostname() string {
	if m != nil && m.RegisterHostname != nil {
		return *m.RegisterHostname
	}
	return ""
}

func (m *Config) GetRegisterLocation() string {
	if m != nil && m.RegisterLocation != nil {
		return *m.RegisterLocation
	}
	return ""
}

func (m *Config) GetRegisterUrl() string {
	if m != nil && m.RegisterUrl != nil {
		return *m.RegisterUrl
	}
	return ""
}

func (m *Config) GetCertRequired() bool {
	if m != nil && m.CertRequired != nil {
		return *m.CertRequired
	}
	return false
}

func (m *Config) GetForceExternalAuth() bool {
	if m != nil && m.ForceExternalAuth != nil {
		return *m.ForceExternalAuth
	}
	return false
}

func (m *Config) GetBonjour() bool {
	if m != nil && m.Bonjour != nil {
		return *m.Bonjour
	}
	return false
}

func (m *Config) GetAllowPing() bool {
	if m != nil && m.AllowPing != nil {
		return *m.AllowPing
	}
	return false
}

func (m *Config) GetUsername() string {
	if m != nil && m.Username != nil {
		return *m.Username
	}
	return ""
}

func (m *Config) GetChannelname() string {
	if m != nil && m.Channelname != nil {
		return *m.Channelname
	}
	return ""
}

func (m *Config) GetSuggestVersion() *Version {
	if m != nil {
		return m.SuggestVersion
	}
	return nil
}

func (m *Config) GetSuggestPositional() bool {
	if m != nil && m.SuggestPositional != nil {
		return *m.SuggestPositional
	}
	return false
}

func (m *Config) GetSuggestPushToTalk() bool {
	if m != nil && m.SuggestPushToTalk != nil {
		return *m.SuggestPushToTalk
	}
	return false
}

func (m *Config) GetOpusThreshold() uint32 {
	if m != nil && m.OpusThreshold != nil {
		return *m.OpusThreshold
	}
	return 0
}

func (m *Config) GetChannelNestingLimit() uint32 {
	if m != nil && m.ChannelNestingLimit != nil {
		return *m.ChannelNestingLimit
	}
	return 0
}

type Config_Query struct {
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Config_Query) Reset()         { *m = Config_Query{} }
func (m *Config_Query) String() string { return proto.CompactTextString(m) }
func (*Config_Query) ProtoMessage()    {}

func (m *Config_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

type Channel struct {
	Server           *Server    `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	Id               *uint32    `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	Name             *string    `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	Parent           *Channel   `protobuf:"bytes,4,opt,name=parent" json:"parent,omitempty"`
	Links            []*Channel `protobuf:"bytes,5,rep,name=links" json:"links,omitempty"`
	Description      *string    `protobuf:"bytes,6,opt,name=description" json:"description,omitempty"`
	Temporary        *bool      `protobuf:"varint,7,opt,name=temporary" json:"temporary,omitempty"`
	Position         *int32     `protobuf:"varint,8,opt,name=position" json:"position,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *Channel) Reset()         { *m = Channel{} }
func (m *Channel) String() string { return proto.CompactTextString(m) }
func (*Channel) ProtoMessage()    {}

func (m *Channel) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Channel) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Channel) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Channel) GetParent() *Channel {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *Channel) GetLinks() []*Channel {
	if m != nil {
		return m.Links
	}
	return nil
}

func (m *Channel) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *Channel) GetTemporary() bool {
	if m != nil && m.Temporary != nil {
		return *m.Temporary
	}
	return false
}

func (m *Channel) GetPosition() int32 {
	if m != nil && m.Position != nil {
		return *m.Position
	}
	return 0
}

type Channel_Query struct {
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Channel_Query) Reset()         { *m = Channel_Query{} }
func (m *Channel_Query) String() string { return proto.CompactTextString(m) }
func (*Channel_Query) ProtoMessage()    {}

func (m *Channel_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

type Channel_List struct {
	Server           *Server    `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	Channels         []*Channel `protobuf:"bytes,2,rep,name=channels" json:"channels,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *Channel_List) Reset()         { *m = Channel_List{} }
func (m *Channel_List) String() string { return proto.CompactTextString(m) }
func (*Channel_List) ProtoMessage()    {}

func (m *Channel_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Channel_List) GetChannels() []*Channel {
	if m != nil {
		return m.Channels
	}
	return nil
}

type User struct {
	Server           *Server  `protobuf:"bytes,50,opt,name=server" json:"server,omitempty"`
	Session          *uint32  `protobuf:"varint,1,opt,name=session" json:"session,omitempty"`
	Id               *uint32  `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	Name             *string  `protobuf:"bytes,11,opt,name=name" json:"name,omitempty"`
	Mute             *bool    `protobuf:"varint,3,opt,name=mute" json:"mute,omitempty"`
	Deaf             *bool    `protobuf:"varint,4,opt,name=deaf" json:"deaf,omitempty"`
	Suppress         *bool    `protobuf:"varint,5,opt,name=suppress" json:"suppress,omitempty"`
	PrioritySpeaker  *bool    `protobuf:"varint,6,opt,name=priority_speaker" json:"priority_speaker,omitempty"`
	SelfMute         *bool    `protobuf:"varint,7,opt,name=self_mute" json:"self_mute,omitempty"`
	SelfDeaf         *bool    `protobuf:"varint,8,opt,name=self_deaf" json:"self_deaf,omitempty"`
	Recording        *bool    `protobuf:"varint,9,opt,name=recording" json:"recording,omitempty"`
	Channel          *Channel `protobuf:"bytes,10,opt,name=channel" json:"channel,omitempty"`
	OnlineSecs       *uint32  `protobuf:"varint,12,opt,name=online_secs" json:"online_secs,omitempty"`
	IdleSecs         *uint32  `protobuf:"varint,13,opt,name=idle_secs" json:"idle_secs,omitempty"`
	BytesPerSec      *uint32  `protobuf:"varint,14,opt,name=bytes_per_sec" json:"bytes_per_sec,omitempty"`
	Version          *Version `protobuf:"bytes,15,opt,name=version" json:"version,omitempty"`
	PluginContext    []byte   `protobuf:"bytes,16,opt,name=plugin_context" json:"plugin_context,omitempty"`
	PluginIdentity   *string  `protobuf:"bytes,17,opt,name=plugin_identity" json:"plugin_identity,omitempty"`
	Comment          *string  `protobuf:"bytes,18,opt,name=comment" json:"comment,omitempty"`
	Texture          []byte   `protobuf:"bytes,19,opt,name=texture" json:"texture,omitempty"`
	Address          []byte   `protobuf:"bytes,20,opt,name=address" json:"address,omitempty"`
	TcpOnly          *bool    `protobuf:"varint,21,opt,name=tcp_only" json:"tcp_only,omitempty"`
	UdpPing          *float32 `protobuf:"fixed32,22,opt,name=udp_ping" json:"udp_ping,omitempty"`
	TcpPing          *float32 `protobuf:"fixed32,23,opt,name=tcp_ping" json:"tcp_ping,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}

func (m *User) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *User) GetSession() uint32 {
	if m != nil && m.Session != nil {
		return *m.Session
	}
	return 0
}

func (m *User) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *User) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *User) GetMute() bool {
	if m != nil && m.Mute != nil {
		return *m.Mute
	}
	return false
}

func (m *User) GetDeaf() bool {
	if m != nil && m.Deaf != nil {
		return *m.Deaf
	}
	return false
}

func (m *User) GetSuppress() bool {
	if m != nil && m.Suppress != nil {
		return *m.Suppress
	}
	return false
}

func (m *User) GetPrioritySpeaker() bool {
	if m != nil && m.PrioritySpeaker != nil {
		return *m.PrioritySpeaker
	}
	return false
}

func (m *User) GetSelfMute() bool {
	if m != nil && m.SelfMute != nil {
		return *m.SelfMute
	}
	return false
}

func (m *User) GetSelfDeaf() bool {
	if m != nil && m.SelfDeaf != nil {
		return *m.SelfDeaf
	}
	return false
}

func (m *User) GetRecording() bool {
	if m != nil && m.Recording != nil {
		return *m.Recording
	}
	return false
}

func (m *User) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *User) GetOnlineSecs() uint32 {
	if m != nil && m.OnlineSecs != nil {
		return *m.OnlineSecs
	}
	return 0
}

func (m *User) GetIdleSecs() uint32 {
	if m != nil && m.IdleSecs != nil {
		return *m.IdleSecs
	}
	return 0
}

func (m *User) GetBytesPerSec() uint32 {
	if m != nil && m.BytesPerSec != nil {
		return *m.BytesPerSec
	}
	return 0
}

func (m *User) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *User) GetPluginContext() []byte {
	if m != nil {
		return m.PluginContext
	}
	return nil
}

func (m *User) GetPluginIdentity() string {
	if m != nil && m.PluginIdentity != nil {
		return *m.PluginIdentity
	}
	return ""
}

func (m *User) GetComment() string {
	if m != nil && m.Comment != nil {
		return *m.Comment
	}
	return ""
}

func (m *User) GetTexture() []byte {
	if m != nil {
		return m.Texture
	}
	return nil
}

func (m *User) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *User) GetTcpOnly() bool {
	if m != nil && m.TcpOnly != nil {
		return *m.TcpOnly
	}
	return false
}

func (m *User) GetUdpPing() float32 {
	if m != nil && m.UdpPing != nil {
		return *m.UdpPing
	}
	return 0
}

func (m *User) GetTcpPing() float32 {
	if m != nil && m.TcpPing != nil {
		return *m.TcpPing
	}
	return 0
}

type User_Query struct {
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *User_Query) Reset()         { *m = User_Query{} }
func (m *User_Query) String() string { return proto.CompactTextString(m) }
func (*User_Query) ProtoMessage()    {}

func (m *User_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

type User_List struct {
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	Users            []*User `protobuf:"bytes,2,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *User_List) Reset()         { *m = User_List{} }
func (m *User_List) String() string { return proto.CompactTextString(m) }
func (*User_List) ProtoMessage()    {}

func (m *User_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *User_List) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

type User_Kick struct {
	// TODO(grpc): server is not really required here, since it's embedded in
	// user.
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	User             *User   `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	Reason           *string `protobuf:"bytes,3,opt,name=reason" json:"reason,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *User_Kick) Reset()         { *m = User_Kick{} }
func (m *User_Kick) String() string { return proto.CompactTextString(m) }
func (*User_Kick) ProtoMessage()    {}

func (m *User_Kick) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *User_Kick) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *User_Kick) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

type Tree struct {
	Server           *Server  `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	Channel          *Channel `protobuf:"bytes,2,opt,name=channel" json:"channel,omitempty"`
	Children         []*Tree  `protobuf:"bytes,3,rep,name=children" json:"children,omitempty"`
	Users            []*User  `protobuf:"bytes,4,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Tree) Reset()         { *m = Tree{} }
func (m *Tree) String() string { return proto.CompactTextString(m) }
func (*Tree) ProtoMessage()    {}

func (m *Tree) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Tree) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *Tree) GetChildren() []*Tree {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Tree) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

type Ban struct {
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	Address          []byte  `protobuf:"bytes,2,opt,name=address" json:"address,omitempty"`
	Bits             *uint32 `protobuf:"varint,3,opt,name=bits" json:"bits,omitempty"`
	Name             *string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	Hash             *string `protobuf:"bytes,5,opt,name=hash" json:"hash,omitempty"`
	Reason           *string `protobuf:"bytes,6,opt,name=reason" json:"reason,omitempty"`
	Start            *int64  `protobuf:"varint,7,opt,name=start" json:"start,omitempty"`
	Duration         *int64  `protobuf:"varint,8,opt,name=duration" json:"duration,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Ban) Reset()         { *m = Ban{} }
func (m *Ban) String() string { return proto.CompactTextString(m) }
func (*Ban) ProtoMessage()    {}

func (m *Ban) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Ban) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *Ban) GetBits() uint32 {
	if m != nil && m.Bits != nil {
		return *m.Bits
	}
	return 0
}

func (m *Ban) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Ban) GetHash() string {
	if m != nil && m.Hash != nil {
		return *m.Hash
	}
	return ""
}

func (m *Ban) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

func (m *Ban) GetStart() int64 {
	if m != nil && m.Start != nil {
		return *m.Start
	}
	return 0
}

func (m *Ban) GetDuration() int64 {
	if m != nil && m.Duration != nil {
		return *m.Duration
	}
	return 0
}

type ACL struct {
	ApplyHere        *bool           `protobuf:"varint,3,opt,name=apply_here" json:"apply_here,omitempty"`
	ApplySubs        *bool           `protobuf:"varint,4,opt,name=apply_subs" json:"apply_subs,omitempty"`
	Inherited        *bool           `protobuf:"varint,5,opt,name=inherited" json:"inherited,omitempty"`
	User             *DatabaseUser   `protobuf:"bytes,6,opt,name=user" json:"user,omitempty"`
	Group            *string         `protobuf:"bytes,7,opt,name=group" json:"group,omitempty"`
	Allow            *ACL_Permission `protobuf:"varint,8,opt,name=allow,enum=MurmurRPC.ACL_Permission" json:"allow,omitempty"`
	Deny             *ACL_Permission `protobuf:"varint,9,opt,name=deny,enum=MurmurRPC.ACL_Permission" json:"deny,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *ACL) Reset()         { *m = ACL{} }
func (m *ACL) String() string { return proto.CompactTextString(m) }
func (*ACL) ProtoMessage()    {}

func (m *ACL) GetApplyHere() bool {
	if m != nil && m.ApplyHere != nil {
		return *m.ApplyHere
	}
	return false
}

func (m *ACL) GetApplySubs() bool {
	if m != nil && m.ApplySubs != nil {
		return *m.ApplySubs
	}
	return false
}

func (m *ACL) GetInherited() bool {
	if m != nil && m.Inherited != nil {
		return *m.Inherited
	}
	return false
}

func (m *ACL) GetUser() *DatabaseUser {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ACL) GetGroup() string {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return ""
}

func (m *ACL) GetAllow() ACL_Permission {
	if m != nil && m.Allow != nil {
		return *m.Allow
	}
	return ACL_None
}

func (m *ACL) GetDeny() ACL_Permission {
	if m != nil && m.Deny != nil {
		return *m.Deny
	}
	return ACL_None
}

type ACL_Group struct {
	Name             *string         `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Inherited        *bool           `protobuf:"varint,2,opt,name=inherited" json:"inherited,omitempty"`
	Inherit          *bool           `protobuf:"varint,3,opt,name=inherit" json:"inherit,omitempty"`
	Inheritable      *bool           `protobuf:"varint,4,opt,name=inheritable" json:"inheritable,omitempty"`
	UsersAdd         []*DatabaseUser `protobuf:"bytes,5,rep,name=users_add" json:"users_add,omitempty"`
	UsersRemove      []*DatabaseUser `protobuf:"bytes,6,rep,name=users_remove" json:"users_remove,omitempty"`
	Users            []*DatabaseUser `protobuf:"bytes,7,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *ACL_Group) Reset()         { *m = ACL_Group{} }
func (m *ACL_Group) String() string { return proto.CompactTextString(m) }
func (*ACL_Group) ProtoMessage()    {}

func (m *ACL_Group) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ACL_Group) GetInherited() bool {
	if m != nil && m.Inherited != nil {
		return *m.Inherited
	}
	return false
}

func (m *ACL_Group) GetInherit() bool {
	if m != nil && m.Inherit != nil {
		return *m.Inherit
	}
	return false
}

func (m *ACL_Group) GetInheritable() bool {
	if m != nil && m.Inheritable != nil {
		return *m.Inheritable
	}
	return false
}

func (m *ACL_Group) GetUsersAdd() []*DatabaseUser {
	if m != nil {
		return m.UsersAdd
	}
	return nil
}

func (m *ACL_Group) GetUsersRemove() []*DatabaseUser {
	if m != nil {
		return m.UsersRemove
	}
	return nil
}

func (m *ACL_Group) GetUsers() []*DatabaseUser {
	if m != nil {
		return m.Users
	}
	return nil
}

type ACL_List struct {
	Server           *Server  `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	Channel          *Channel `protobuf:"bytes,2,opt,name=channel" json:"channel,omitempty"`
	Acls             []*ACL   `protobuf:"bytes,3,rep,name=acls" json:"acls,omitempty"`
	Groups           []string `protobuf:"bytes,4,rep,name=groups" json:"groups,omitempty"`
	Inherit          *bool    `protobuf:"varint,5,opt,name=inherit" json:"inherit,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ACL_List) Reset()         { *m = ACL_List{} }
func (m *ACL_List) String() string { return proto.CompactTextString(m) }
func (*ACL_List) ProtoMessage()    {}

func (m *ACL_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *ACL_List) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *ACL_List) GetAcls() []*ACL {
	if m != nil {
		return m.Acls
	}
	return nil
}

func (m *ACL_List) GetGroups() []string {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *ACL_List) GetInherit() bool {
	if m != nil && m.Inherit != nil {
		return *m.Inherit
	}
	return false
}

type ACL_TemporaryGroup struct {
	Server           *Server  `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	Channel          *Channel `protobuf:"bytes,2,opt,name=channel" json:"channel,omitempty"`
	User             *User    `protobuf:"bytes,3,opt,name=user" json:"user,omitempty"`
	Group            *string  `protobuf:"bytes,4,opt,name=group" json:"group,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ACL_TemporaryGroup) Reset()         { *m = ACL_TemporaryGroup{} }
func (m *ACL_TemporaryGroup) String() string { return proto.CompactTextString(m) }
func (*ACL_TemporaryGroup) ProtoMessage()    {}

func (m *ACL_TemporaryGroup) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *ACL_TemporaryGroup) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *ACL_TemporaryGroup) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ACL_TemporaryGroup) GetGroup() string {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return ""
}

type Authenticator struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Authenticator) Reset()         { *m = Authenticator{} }
func (m *Authenticator) String() string { return proto.CompactTextString(m) }
func (*Authenticator) ProtoMessage()    {}

type Authenticator_Message struct {
	Server           *Server                     `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	Type             *Authenticator_Message_Type `protobuf:"varint,2,opt,name=type,enum=MurmurRPC.Authenticator_Message_Type" json:"type,omitempty"`
	User             *User                       `protobuf:"bytes,3,opt,name=user" json:"user,omitempty"`
	DatabaseUser     []*DatabaseUser             `protobuf:"bytes,4,rep,name=database_user" json:"database_user,omitempty"`
	Groups           []string                    `protobuf:"bytes,5,rep,name=groups" json:"groups,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *Authenticator_Message) Reset()         { *m = Authenticator_Message{} }
func (m *Authenticator_Message) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Message) ProtoMessage()    {}

func (m *Authenticator_Message) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Authenticator_Message) GetType() Authenticator_Message_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Authenticator_Message_Initialize
}

func (m *Authenticator_Message) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Authenticator_Message) GetDatabaseUser() []*DatabaseUser {
	if m != nil {
		return m.DatabaseUser
	}
	return nil
}

func (m *Authenticator_Message) GetGroups() []string {
	if m != nil {
		return m.Groups
	}
	return nil
}

type DatabaseUser struct {
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	Id               *uint32 `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	Name             *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	Email            *string `protobuf:"bytes,4,opt,name=email" json:"email,omitempty"`
	Comment          *string `protobuf:"bytes,5,opt,name=comment" json:"comment,omitempty"`
	Hash             *string `protobuf:"bytes,6,opt,name=hash" json:"hash,omitempty"`
	Password         *string `protobuf:"bytes,7,opt,name=password" json:"password,omitempty"`
	LastActive       *string `protobuf:"bytes,8,opt,name=last_active" json:"last_active,omitempty"`
	Texture          []byte  `protobuf:"bytes,9,opt,name=texture" json:"texture,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DatabaseUser) Reset()         { *m = DatabaseUser{} }
func (m *DatabaseUser) String() string { return proto.CompactTextString(m) }
func (*DatabaseUser) ProtoMessage()    {}

func (m *DatabaseUser) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *DatabaseUser) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *DatabaseUser) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *DatabaseUser) GetEmail() string {
	if m != nil && m.Email != nil {
		return *m.Email
	}
	return ""
}

func (m *DatabaseUser) GetComment() string {
	if m != nil && m.Comment != nil {
		return *m.Comment
	}
	return ""
}

func (m *DatabaseUser) GetHash() string {
	if m != nil && m.Hash != nil {
		return *m.Hash
	}
	return ""
}

func (m *DatabaseUser) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *DatabaseUser) GetLastActive() string {
	if m != nil && m.LastActive != nil {
		return *m.LastActive
	}
	return ""
}

func (m *DatabaseUser) GetTexture() []byte {
	if m != nil {
		return m.Texture
	}
	return nil
}

type DatabaseUser_Query struct {
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	Filter           *string `protobuf:"bytes,2,opt,name=filter" json:"filter,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DatabaseUser_Query) Reset()         { *m = DatabaseUser_Query{} }
func (m *DatabaseUser_Query) String() string { return proto.CompactTextString(m) }
func (*DatabaseUser_Query) ProtoMessage()    {}

func (m *DatabaseUser_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *DatabaseUser_Query) GetFilter() string {
	if m != nil && m.Filter != nil {
		return *m.Filter
	}
	return ""
}

type DatabaseUser_List struct {
	Server           *Server         `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	Users            []*DatabaseUser `protobuf:"bytes,2,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *DatabaseUser_List) Reset()         { *m = DatabaseUser_List{} }
func (m *DatabaseUser_List) String() string { return proto.CompactTextString(m) }
func (*DatabaseUser_List) ProtoMessage()    {}

func (m *DatabaseUser_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *DatabaseUser_List) GetUsers() []*DatabaseUser {
	if m != nil {
		return m.Users
	}
	return nil
}

type DatabaseUser_Verify struct {
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	Name             *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Password         *string `protobuf:"bytes,3,opt,name=password" json:"password,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DatabaseUser_Verify) Reset()         { *m = DatabaseUser_Verify{} }
func (m *DatabaseUser_Verify) String() string { return proto.CompactTextString(m) }
func (*DatabaseUser_Verify) ProtoMessage()    {}

func (m *DatabaseUser_Verify) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *DatabaseUser_Verify) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *DatabaseUser_Verify) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

type RedirectWhisperGroup struct {
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	User             *User   `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	Source           *string `protobuf:"bytes,3,opt,name=source" json:"source,omitempty"`
	Target           *string `protobuf:"bytes,4,opt,name=target" json:"target,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RedirectWhisperGroup) Reset()         { *m = RedirectWhisperGroup{} }
func (m *RedirectWhisperGroup) String() string { return proto.CompactTextString(m) }
func (*RedirectWhisperGroup) ProtoMessage()    {}

func (m *RedirectWhisperGroup) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *RedirectWhisperGroup) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *RedirectWhisperGroup) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *RedirectWhisperGroup) GetTarget() string {
	if m != nil && m.Target != nil {
		return *m.Target
	}
	return ""
}

func init() {
	proto.RegisterEnum("MurmurRPC.Server_Event_Type", Server_Event_Type_name, Server_Event_Type_value)
	proto.RegisterEnum("MurmurRPC.Event_Type", Event_Type_name, Event_Type_value)
	proto.RegisterEnum("MurmurRPC.ContextAction_Context", ContextAction_Context_name, ContextAction_Context_value)
	proto.RegisterEnum("MurmurRPC.ACL_Permission", ACL_Permission_name, ACL_Permission_value)
	proto.RegisterEnum("MurmurRPC.Authenticator_Message_Type", Authenticator_Message_Type_name, Authenticator_Message_Type_value)
}

// Client API for ServerService service

type ServerServiceClient interface {
	// Create creates a new virtual server.
	Create(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Server, error)
	// Query returns a list of servers that match the given query.
	Query(ctx context.Context, in *Server_Query, opts ...grpc.CallOption) (*Server_List, error)
	// Get returns information about the given server.
	Get(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Server, error)
	// Start starts the given stopped server.
	Start(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error)
	// Stop stops the given virtual server.
	Stop(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error)
	// Remove removes the given virtual server and its configuration.
	Remove(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error)
	Events(ctx context.Context, in *Server, opts ...grpc.CallOption) (ServerService_EventsClient, error)
}

type serverServiceClient struct {
	cc *grpc.ClientConn
}

func NewServerServiceClient(cc *grpc.ClientConn) ServerServiceClient {
	return &serverServiceClient{cc}
}

func (c *serverServiceClient) Create(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Server, error) {
	out := new(Server)
	err := grpc.Invoke(ctx, "/MurmurRPC.ServerService/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) Query(ctx context.Context, in *Server_Query, opts ...grpc.CallOption) (*Server_List, error) {
	out := new(Server_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.ServerService/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) Get(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Server, error) {
	out := new(Server)
	err := grpc.Invoke(ctx, "/MurmurRPC.ServerService/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) Start(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ServerService/Start", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) Stop(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ServerService/Stop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) Remove(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ServerService/Remove", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) Events(ctx context.Context, in *Server, opts ...grpc.CallOption) (ServerService_EventsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ServerService_serviceDesc.Streams[0], c.cc, "/MurmurRPC.ServerService/Events", opts...)
	if err != nil {
		return nil, err
	}
	x := &serverServiceEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ServerService_EventsClient interface {
	Recv() (*Server_Event, error)
	grpc.ClientStream
}

type serverServiceEventsClient struct {
	grpc.ClientStream
}

func (x *serverServiceEventsClient) Recv() (*Server_Event, error) {
	m := new(Server_Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ServerService service

type ServerServiceServer interface {
	// Create creates a new virtual server.
	Create(context.Context, *Void) (*Server, error)
	// Query returns a list of servers that match the given query.
	Query(context.Context, *Server_Query) (*Server_List, error)
	// Get returns information about the given server.
	Get(context.Context, *Server) (*Server, error)
	// Start starts the given stopped server.
	Start(context.Context, *Server) (*Void, error)
	// Stop stops the given virtual server.
	Stop(context.Context, *Server) (*Void, error)
	// Remove removes the given virtual server and its configuration.
	Remove(context.Context, *Server) (*Void, error)
	Events(*Server, ServerService_EventsServer) error
}

func RegisterServerServiceServer(s *grpc.Server, srv ServerServiceServer) {
	s.RegisterService(&_ServerService_serviceDesc, srv)
}

func _ServerService_Create_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Void)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ServerServiceServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ServerService_Query_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Server_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ServerServiceServer).Query(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ServerService_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Server)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ServerServiceServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ServerService_Start_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Server)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ServerServiceServer).Start(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ServerService_Stop_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Server)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ServerServiceServer).Stop(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ServerService_Remove_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Server)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ServerServiceServer).Remove(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ServerService_Events_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Server)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ServerServiceServer).Events(m, &serverServiceEventsServer{stream})
}

type ServerService_EventsServer interface {
	Send(*Server_Event) error
	grpc.ServerStream
}

type serverServiceEventsServer struct {
	grpc.ServerStream
}

func (x *serverServiceEventsServer) Send(m *Server_Event) error {
	return x.ServerStream.SendMsg(m)
}

var _ServerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.ServerService",
	HandlerType: (*ServerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _ServerService_Create_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _ServerService_Query_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ServerService_Get_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _ServerService_Start_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _ServerService_Stop_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _ServerService_Remove_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Events",
			Handler:       _ServerService_Events_Handler,
			ServerStreams: true,
		},
	},
}

// Client API for MetaService service

type MetaServiceClient interface {
	// Get murmur's uptime.
	GetUptime(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Uptime, error)
	// Get murmur's version.
	GetVersion(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Version, error)
	Events(ctx context.Context, in *Void, opts ...grpc.CallOption) (MetaService_EventsClient, error)
}

type metaServiceClient struct {
	cc *grpc.ClientConn
}

func NewMetaServiceClient(cc *grpc.ClientConn) MetaServiceClient {
	return &metaServiceClient{cc}
}

func (c *metaServiceClient) GetUptime(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Uptime, error) {
	out := new(Uptime)
	err := grpc.Invoke(ctx, "/MurmurRPC.MetaService/GetUptime", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) GetVersion(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Version, error) {
	out := new(Version)
	err := grpc.Invoke(ctx, "/MurmurRPC.MetaService/GetVersion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) Events(ctx context.Context, in *Void, opts ...grpc.CallOption) (MetaService_EventsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MetaService_serviceDesc.Streams[0], c.cc, "/MurmurRPC.MetaService/Events", opts...)
	if err != nil {
		return nil, err
	}
	x := &metaServiceEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MetaService_EventsClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type metaServiceEventsClient struct {
	grpc.ClientStream
}

func (x *metaServiceEventsClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for MetaService service

type MetaServiceServer interface {
	// Get murmur's uptime.
	GetUptime(context.Context, *Void) (*Uptime, error)
	// Get murmur's version.
	GetVersion(context.Context, *Void) (*Version, error)
	Events(*Void, MetaService_EventsServer) error
}

func RegisterMetaServiceServer(s *grpc.Server, srv MetaServiceServer) {
	s.RegisterService(&_MetaService_serviceDesc, srv)
}

func _MetaService_GetUptime_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Void)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(MetaServiceServer).GetUptime(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _MetaService_GetVersion_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Void)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(MetaServiceServer).GetVersion(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _MetaService_Events_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Void)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MetaServiceServer).Events(m, &metaServiceEventsServer{stream})
}

type MetaService_EventsServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type metaServiceEventsServer struct {
	grpc.ServerStream
}

func (x *metaServiceEventsServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

var _MetaService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.MetaService",
	HandlerType: (*MetaServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUptime",
			Handler:    _MetaService_GetUptime_Handler,
		},
		{
			MethodName: "GetVersion",
			Handler:    _MetaService_GetVersion_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Events",
			Handler:       _MetaService_Events_Handler,
			ServerStreams: true,
		},
	},
}

// Client API for ContextActionService service

type ContextActionServiceClient interface {
	// Add adds a context action to the given user's client. Fields must be set:
	//   context, action, text, and user.
	Add(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error)
	// Remove removes a context action from the given user's client. Fields must
	// be set:
	//   action
	// If no user is given, the context action is removed from all users.
	Remove(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error)
	// Events returns a stream of context action events that are triggered by
	// users.
	Events(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (ContextActionService_EventsClient, error)
}

type contextActionServiceClient struct {
	cc *grpc.ClientConn
}

func NewContextActionServiceClient(cc *grpc.ClientConn) ContextActionServiceClient {
	return &contextActionServiceClient{cc}
}

func (c *contextActionServiceClient) Add(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ContextActionService/Add", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contextActionServiceClient) Remove(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ContextActionService/Remove", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contextActionServiceClient) Events(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (ContextActionService_EventsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ContextActionService_serviceDesc.Streams[0], c.cc, "/MurmurRPC.ContextActionService/Events", opts...)
	if err != nil {
		return nil, err
	}
	x := &contextActionServiceEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ContextActionService_EventsClient interface {
	Recv() (*ContextAction, error)
	grpc.ClientStream
}

type contextActionServiceEventsClient struct {
	grpc.ClientStream
}

func (x *contextActionServiceEventsClient) Recv() (*ContextAction, error) {
	m := new(ContextAction)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ContextActionService service

type ContextActionServiceServer interface {
	// Add adds a context action to the given user's client. Fields must be set:
	//   context, action, text, and user.
	Add(context.Context, *ContextAction) (*Void, error)
	// Remove removes a context action from the given user's client. Fields must
	// be set:
	//   action
	// If no user is given, the context action is removed from all users.
	Remove(context.Context, *ContextAction) (*Void, error)
	// Events returns a stream of context action events that are triggered by
	// users.
	Events(*ContextAction, ContextActionService_EventsServer) error
}

func RegisterContextActionServiceServer(s *grpc.Server, srv ContextActionServiceServer) {
	s.RegisterService(&_ContextActionService_serviceDesc, srv)
}

func _ContextActionService_Add_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ContextAction)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ContextActionServiceServer).Add(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ContextActionService_Remove_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ContextAction)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ContextActionServiceServer).Remove(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ContextActionService_Events_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ContextAction)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ContextActionServiceServer).Events(m, &contextActionServiceEventsServer{stream})
}

type ContextActionService_EventsServer interface {
	Send(*ContextAction) error
	grpc.ServerStream
}

type contextActionServiceEventsServer struct {
	grpc.ServerStream
}

func (x *contextActionServiceEventsServer) Send(m *ContextAction) error {
	return x.ServerStream.SendMsg(m)
}

var _ContextActionService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.ContextActionService",
	HandlerType: (*ContextActionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _ContextActionService_Add_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _ContextActionService_Remove_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Events",
			Handler:       _ContextActionService_Events_Handler,
			ServerStreams: true,
		},
	},
}

// Client API for TextMessageService service

type TextMessageServiceClient interface {
	// Send sends the given TextMessage to the server.
	//
	// If users, channels, and trees are not set in the TextMessage, the message
	// will be broadcast the entire server. Otherwise, the message will be
	// targeted to the specified users, channels, and trees.
	Send(ctx context.Context, in *TextMessage, opts ...grpc.CallOption) (*Void, error)
}

type textMessageServiceClient struct {
	cc *grpc.ClientConn
}

func NewTextMessageServiceClient(cc *grpc.ClientConn) TextMessageServiceClient {
	return &textMessageServiceClient{cc}
}

func (c *textMessageServiceClient) Send(ctx context.Context, in *TextMessage, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.TextMessageService/Send", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TextMessageService service

type TextMessageServiceServer interface {
	// Send sends the given TextMessage to the server.
	//
	// If users, channels, and trees are not set in the TextMessage, the message
	// will be broadcast the entire server. Otherwise, the message will be
	// targeted to the specified users, channels, and trees.
	Send(context.Context, *TextMessage) (*Void, error)
}

func RegisterTextMessageServiceServer(s *grpc.Server, srv TextMessageServiceServer) {
	s.RegisterService(&_TextMessageService_serviceDesc, srv)
}

func _TextMessageService_Send_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(TextMessage)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(TextMessageServiceServer).Send(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _TextMessageService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.TextMessageService",
	HandlerType: (*TextMessageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _TextMessageService_Send_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for LogService service

type LogServiceClient interface {
}

type logServiceClient struct {
	cc *grpc.ClientConn
}

func NewLogServiceClient(cc *grpc.ClientConn) LogServiceClient {
	return &logServiceClient{cc}
}

// Server API for LogService service

type LogServiceServer interface {
}

func RegisterLogServiceServer(s *grpc.Server, srv LogServiceServer) {
	s.RegisterService(&_LogService_serviceDesc, srv)
}

var _LogService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.LogService",
	HandlerType: (*LogServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams:     []grpc.StreamDesc{},
}

// Client API for ConfigService service

type ConfigServiceClient interface {
	GetDefault(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Config, error)
	SetDefault(ctx context.Context, in *Config, opts ...grpc.CallOption) (*Void, error)
	Query(ctx context.Context, in *Config_Query, opts ...grpc.CallOption) (*Config, error)
}

type configServiceClient struct {
	cc *grpc.ClientConn
}

func NewConfigServiceClient(cc *grpc.ClientConn) ConfigServiceClient {
	return &configServiceClient{cc}
}

func (c *configServiceClient) GetDefault(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Config, error) {
	out := new(Config)
	err := grpc.Invoke(ctx, "/MurmurRPC.ConfigService/GetDefault", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) SetDefault(ctx context.Context, in *Config, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ConfigService/SetDefault", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) Query(ctx context.Context, in *Config_Query, opts ...grpc.CallOption) (*Config, error) {
	out := new(Config)
	err := grpc.Invoke(ctx, "/MurmurRPC.ConfigService/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ConfigService service

type ConfigServiceServer interface {
	GetDefault(context.Context, *Void) (*Config, error)
	SetDefault(context.Context, *Config) (*Void, error)
	Query(context.Context, *Config_Query) (*Config, error)
}

func RegisterConfigServiceServer(s *grpc.Server, srv ConfigServiceServer) {
	s.RegisterService(&_ConfigService_serviceDesc, srv)
}

func _ConfigService_GetDefault_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Void)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ConfigServiceServer).GetDefault(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ConfigService_SetDefault_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Config)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ConfigServiceServer).SetDefault(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ConfigService_Query_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Config_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ConfigServiceServer).Query(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _ConfigService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.ConfigService",
	HandlerType: (*ConfigServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDefault",
			Handler:    _ConfigService_GetDefault_Handler,
		},
		{
			MethodName: "SetDefault",
			Handler:    _ConfigService_SetDefault_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _ConfigService_Query_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for ChannelService service

type ChannelServiceClient interface {
	// Query returns a list of channels that match the given query.
	Query(ctx context.Context, in *Channel_Query, opts ...grpc.CallOption) (*Channel_List, error)
	// Get returns the channel with the given ID.
	Get(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error)
	// Add adds the channel to the given server. The parent and name of the
	// channel must be set.
	Add(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error)
	// Remove removes the given channel from the server.
	Remove(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Void, error)
	// Update updates the given channel's attributes. Only the fields that are
	// set will be updated.
	Update(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error)
}

type channelServiceClient struct {
	cc *grpc.ClientConn
}

func NewChannelServiceClient(cc *grpc.ClientConn) ChannelServiceClient {
	return &channelServiceClient{cc}
}

func (c *channelServiceClient) Query(ctx context.Context, in *Channel_Query, opts ...grpc.CallOption) (*Channel_List, error) {
	out := new(Channel_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.ChannelService/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelServiceClient) Get(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error) {
	out := new(Channel)
	err := grpc.Invoke(ctx, "/MurmurRPC.ChannelService/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelServiceClient) Add(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error) {
	out := new(Channel)
	err := grpc.Invoke(ctx, "/MurmurRPC.ChannelService/Add", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelServiceClient) Remove(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ChannelService/Remove", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelServiceClient) Update(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error) {
	out := new(Channel)
	err := grpc.Invoke(ctx, "/MurmurRPC.ChannelService/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ChannelService service

type ChannelServiceServer interface {
	// Query returns a list of channels that match the given query.
	Query(context.Context, *Channel_Query) (*Channel_List, error)
	// Get returns the channel with the given ID.
	Get(context.Context, *Channel) (*Channel, error)
	// Add adds the channel to the given server. The parent and name of the
	// channel must be set.
	Add(context.Context, *Channel) (*Channel, error)
	// Remove removes the given channel from the server.
	Remove(context.Context, *Channel) (*Void, error)
	// Update updates the given channel's attributes. Only the fields that are
	// set will be updated.
	Update(context.Context, *Channel) (*Channel, error)
}

func RegisterChannelServiceServer(s *grpc.Server, srv ChannelServiceServer) {
	s.RegisterService(&_ChannelService_serviceDesc, srv)
}

func _ChannelService_Query_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Channel_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ChannelServiceServer).Query(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ChannelService_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Channel)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ChannelServiceServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ChannelService_Add_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Channel)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ChannelServiceServer).Add(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ChannelService_Remove_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Channel)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ChannelServiceServer).Remove(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ChannelService_Update_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Channel)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ChannelServiceServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _ChannelService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.ChannelService",
	HandlerType: (*ChannelServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Query",
			Handler:    _ChannelService_Query_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ChannelService_Get_Handler,
		},
		{
			MethodName: "Add",
			Handler:    _ChannelService_Add_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _ChannelService_Remove_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ChannelService_Update_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for UserService service

type UserServiceClient interface {
	// Query returns a list of connected users who match the given query.
	Query(ctx context.Context, in *User_Query, opts ...grpc.CallOption) (*User_List, error)
	// Get returns information on the connected user, given by the user's session
	// or name.
	Get(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	// Update changes the given user's state. Only the following fields can be
	// changed:
	//   name, mute, deaf, suppress, priority_speaker, channel, comment.
	Update(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	// Kick kicks the user from the server.
	Kick(ctx context.Context, in *User_Kick, opts ...grpc.CallOption) (*Void, error)
}

type userServiceClient struct {
	cc *grpc.ClientConn
}

func NewUserServiceClient(cc *grpc.ClientConn) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) Query(ctx context.Context, in *User_Query, opts ...grpc.CallOption) (*User_List, error) {
	out := new(User_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.UserService/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Get(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/MurmurRPC.UserService/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Update(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/MurmurRPC.UserService/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Kick(ctx context.Context, in *User_Kick, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.UserService/Kick", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for UserService service

type UserServiceServer interface {
	// Query returns a list of connected users who match the given query.
	Query(context.Context, *User_Query) (*User_List, error)
	// Get returns information on the connected user, given by the user's session
	// or name.
	Get(context.Context, *User) (*User, error)
	// Update changes the given user's state. Only the following fields can be
	// changed:
	//   name, mute, deaf, suppress, priority_speaker, channel, comment.
	Update(context.Context, *User) (*User, error)
	// Kick kicks the user from the server.
	Kick(context.Context, *User_Kick) (*Void, error)
}

func RegisterUserServiceServer(s *grpc.Server, srv UserServiceServer) {
	s.RegisterService(&_UserService_serviceDesc, srv)
}

func _UserService_Query_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(User_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(UserServiceServer).Query(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _UserService_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(User)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(UserServiceServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _UserService_Update_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(User)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(UserServiceServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _UserService_Kick_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(User_Kick)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(UserServiceServer).Kick(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _UserService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Query",
			Handler:    _UserService_Query_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _UserService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _UserService_Update_Handler,
		},
		{
			MethodName: "Kick",
			Handler:    _UserService_Kick_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for TreeService service

type TreeServiceClient interface {
	// Get returns a representation of the server's channel/user tree.
	Get(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Tree, error)
}

type treeServiceClient struct {
	cc *grpc.ClientConn
}

func NewTreeServiceClient(cc *grpc.ClientConn) TreeServiceClient {
	return &treeServiceClient{cc}
}

func (c *treeServiceClient) Get(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Tree, error) {
	out := new(Tree)
	err := grpc.Invoke(ctx, "/MurmurRPC.TreeService/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TreeService service

type TreeServiceServer interface {
	// Get returns a representation of the server's channel/user tree.
	Get(context.Context, *Server) (*Tree, error)
}

func RegisterTreeServiceServer(s *grpc.Server, srv TreeServiceServer) {
	s.RegisterService(&_TreeService_serviceDesc, srv)
}

func _TreeService_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Server)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(TreeServiceServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _TreeService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.TreeService",
	HandlerType: (*TreeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _TreeService_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for BanService service

type BanServiceClient interface {
}

type banServiceClient struct {
	cc *grpc.ClientConn
}

func NewBanServiceClient(cc *grpc.ClientConn) BanServiceClient {
	return &banServiceClient{cc}
}

// Server API for BanService service

type BanServiceServer interface {
}

func RegisterBanServiceServer(s *grpc.Server, srv BanServiceServer) {
	s.RegisterService(&_BanService_serviceDesc, srv)
}

var _BanService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.BanService",
	HandlerType: (*BanServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams:     []grpc.StreamDesc{},
}

// Client API for ACLService service

type ACLServiceClient interface {
	Get(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*ACL_List, error)
	Set(ctx context.Context, in *ACL_List, opts ...grpc.CallOption) (*Void, error)
	GetEffectivePermissions(ctx context.Context, in *User, opts ...grpc.CallOption) (*ACL, error)
	AddTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error)
	RemoveTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error)
}

type aCLServiceClient struct {
	cc *grpc.ClientConn
}

func NewACLServiceClient(cc *grpc.ClientConn) ACLServiceClient {
	return &aCLServiceClient{cc}
}

func (c *aCLServiceClient) Get(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*ACL_List, error) {
	out := new(ACL_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.ACLService/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aCLServiceClient) Set(ctx context.Context, in *ACL_List, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ACLService/Set", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aCLServiceClient) GetEffectivePermissions(ctx context.Context, in *User, opts ...grpc.CallOption) (*ACL, error) {
	out := new(ACL)
	err := grpc.Invoke(ctx, "/MurmurRPC.ACLService/GetEffectivePermissions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aCLServiceClient) AddTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ACLService/AddTemporaryGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aCLServiceClient) RemoveTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ACLService/RemoveTemporaryGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ACLService service

type ACLServiceServer interface {
	Get(context.Context, *Channel) (*ACL_List, error)
	Set(context.Context, *ACL_List) (*Void, error)
	GetEffectivePermissions(context.Context, *User) (*ACL, error)
	AddTemporaryGroup(context.Context, *ACL_TemporaryGroup) (*Void, error)
	RemoveTemporaryGroup(context.Context, *ACL_TemporaryGroup) (*Void, error)
}

func RegisterACLServiceServer(s *grpc.Server, srv ACLServiceServer) {
	s.RegisterService(&_ACLService_serviceDesc, srv)
}

func _ACLService_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Channel)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ACLServiceServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ACLService_Set_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ACL_List)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ACLServiceServer).Set(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ACLService_GetEffectivePermissions_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(User)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ACLServiceServer).GetEffectivePermissions(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ACLService_AddTemporaryGroup_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ACL_TemporaryGroup)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ACLServiceServer).AddTemporaryGroup(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ACLService_RemoveTemporaryGroup_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ACL_TemporaryGroup)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ACLServiceServer).RemoveTemporaryGroup(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _ACLService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.ACLService",
	HandlerType: (*ACLServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _ACLService_Get_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _ACLService_Set_Handler,
		},
		{
			MethodName: "GetEffectivePermissions",
			Handler:    _ACLService_GetEffectivePermissions_Handler,
		},
		{
			MethodName: "AddTemporaryGroup",
			Handler:    _ACLService_AddTemporaryGroup_Handler,
		},
		{
			MethodName: "RemoveTemporaryGroup",
			Handler:    _ACLService_RemoveTemporaryGroup_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for AuthenticatorService service

type AuthenticatorServiceClient interface {
	// an initial Authenticator.Response with the "server" set needs to be sent
	// before requests start coming in.
	Stream(ctx context.Context, opts ...grpc.CallOption) (AuthenticatorService_StreamClient, error)
	// same as "stream", but accepts updated registration information.
	RegistrationStream(ctx context.Context, opts ...grpc.CallOption) (AuthenticatorService_RegistrationStreamClient, error)
}

type authenticatorServiceClient struct {
	cc *grpc.ClientConn
}

func NewAuthenticatorServiceClient(cc *grpc.ClientConn) AuthenticatorServiceClient {
	return &authenticatorServiceClient{cc}
}

func (c *authenticatorServiceClient) Stream(ctx context.Context, opts ...grpc.CallOption) (AuthenticatorService_StreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AuthenticatorService_serviceDesc.Streams[0], c.cc, "/MurmurRPC.AuthenticatorService/Stream", opts...)
	if err != nil {
		return nil, err
	}
	x := &authenticatorServiceStreamClient{stream}
	return x, nil
}

type AuthenticatorService_StreamClient interface {
	Send(*Authenticator_Message) error
	Recv() (*Authenticator_Message, error)
	grpc.ClientStream
}

type authenticatorServiceStreamClient struct {
	grpc.ClientStream
}

func (x *authenticatorServiceStreamClient) Send(m *Authenticator_Message) error {
	return x.ClientStream.SendMsg(m)
}

func (x *authenticatorServiceStreamClient) Recv() (*Authenticator_Message, error) {
	m := new(Authenticator_Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *authenticatorServiceClient) RegistrationStream(ctx context.Context, opts ...grpc.CallOption) (AuthenticatorService_RegistrationStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AuthenticatorService_serviceDesc.Streams[1], c.cc, "/MurmurRPC.AuthenticatorService/RegistrationStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &authenticatorServiceRegistrationStreamClient{stream}
	return x, nil
}

type AuthenticatorService_RegistrationStreamClient interface {
	Send(*Authenticator_Message) error
	Recv() (*Authenticator_Message, error)
	grpc.ClientStream
}

type authenticatorServiceRegistrationStreamClient struct {
	grpc.ClientStream
}

func (x *authenticatorServiceRegistrationStreamClient) Send(m *Authenticator_Message) error {
	return x.ClientStream.SendMsg(m)
}

func (x *authenticatorServiceRegistrationStreamClient) Recv() (*Authenticator_Message, error) {
	m := new(Authenticator_Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AuthenticatorService service

type AuthenticatorServiceServer interface {
	// an initial Authenticator.Response with the "server" set needs to be sent
	// before requests start coming in.
	Stream(AuthenticatorService_StreamServer) error
	// same as "stream", but accepts updated registration information.
	RegistrationStream(AuthenticatorService_RegistrationStreamServer) error
}

func RegisterAuthenticatorServiceServer(s *grpc.Server, srv AuthenticatorServiceServer) {
	s.RegisterService(&_AuthenticatorService_serviceDesc, srv)
}

func _AuthenticatorService_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AuthenticatorServiceServer).Stream(&authenticatorServiceStreamServer{stream})
}

type AuthenticatorService_StreamServer interface {
	Send(*Authenticator_Message) error
	Recv() (*Authenticator_Message, error)
	grpc.ServerStream
}

type authenticatorServiceStreamServer struct {
	grpc.ServerStream
}

func (x *authenticatorServiceStreamServer) Send(m *Authenticator_Message) error {
	return x.ServerStream.SendMsg(m)
}

func (x *authenticatorServiceStreamServer) Recv() (*Authenticator_Message, error) {
	m := new(Authenticator_Message)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _AuthenticatorService_RegistrationStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AuthenticatorServiceServer).RegistrationStream(&authenticatorServiceRegistrationStreamServer{stream})
}

type AuthenticatorService_RegistrationStreamServer interface {
	Send(*Authenticator_Message) error
	Recv() (*Authenticator_Message, error)
	grpc.ServerStream
}

type authenticatorServiceRegistrationStreamServer struct {
	grpc.ServerStream
}

func (x *authenticatorServiceRegistrationStreamServer) Send(m *Authenticator_Message) error {
	return x.ServerStream.SendMsg(m)
}

func (x *authenticatorServiceRegistrationStreamServer) Recv() (*Authenticator_Message, error) {
	m := new(Authenticator_Message)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _AuthenticatorService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.AuthenticatorService",
	HandlerType: (*AuthenticatorServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Stream",
			Handler:       _AuthenticatorService_Stream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "RegistrationStream",
			Handler:       _AuthenticatorService_RegistrationStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
}

// Client API for DatabaseService service

type DatabaseServiceClient interface {
	// Query returns a list of registered users who match given query.
	Query(ctx context.Context, in *DatabaseUser_Query, opts ...grpc.CallOption) (*DatabaseUser_List, error)
	// Get returns the database user with the given id.
	Get(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error)
	// Update updates the given database user.
	Update(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error)
	// Register registers a user with the given information on the server. The
	// returned DatabaseUser will contain the newly registered user's ID.
	Register(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error)
	// Deregister deregisters the given user.
	Deregister(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error)
	// Verify verifies the that the given user-password pair is correct.
	Verify(ctx context.Context, in *DatabaseUser_Verify, opts ...grpc.CallOption) (*DatabaseUser, error)
}

type databaseServiceClient struct {
	cc *grpc.ClientConn
}

func NewDatabaseServiceClient(cc *grpc.ClientConn) DatabaseServiceClient {
	return &databaseServiceClient{cc}
}

func (c *databaseServiceClient) Query(ctx context.Context, in *DatabaseUser_Query, opts ...grpc.CallOption) (*DatabaseUser_List, error) {
	out := new(DatabaseUser_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.DatabaseService/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseServiceClient) Get(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error) {
	out := new(DatabaseUser)
	err := grpc.Invoke(ctx, "/MurmurRPC.DatabaseService/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseServiceClient) Update(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.DatabaseService/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseServiceClient) Register(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error) {
	out := new(DatabaseUser)
	err := grpc.Invoke(ctx, "/MurmurRPC.DatabaseService/Register", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseServiceClient) Deregister(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.DatabaseService/Deregister", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseServiceClient) Verify(ctx context.Context, in *DatabaseUser_Verify, opts ...grpc.CallOption) (*DatabaseUser, error) {
	out := new(DatabaseUser)
	err := grpc.Invoke(ctx, "/MurmurRPC.DatabaseService/Verify", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DatabaseService service

type DatabaseServiceServer interface {
	// Query returns a list of registered users who match given query.
	Query(context.Context, *DatabaseUser_Query) (*DatabaseUser_List, error)
	// Get returns the database user with the given id.
	Get(context.Context, *DatabaseUser) (*DatabaseUser, error)
	// Update updates the given database user.
	Update(context.Context, *DatabaseUser) (*Void, error)
	// Register registers a user with the given information on the server. The
	// returned DatabaseUser will contain the newly registered user's ID.
	Register(context.Context, *DatabaseUser) (*DatabaseUser, error)
	// Deregister deregisters the given user.
	Deregister(context.Context, *DatabaseUser) (*Void, error)
	// Verify verifies the that the given user-password pair is correct.
	Verify(context.Context, *DatabaseUser_Verify) (*DatabaseUser, error)
}

func RegisterDatabaseServiceServer(s *grpc.Server, srv DatabaseServiceServer) {
	s.RegisterService(&_DatabaseService_serviceDesc, srv)
}

func _DatabaseService_Query_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DatabaseUser_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DatabaseServiceServer).Query(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DatabaseService_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DatabaseUser)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DatabaseServiceServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DatabaseService_Update_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DatabaseUser)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DatabaseServiceServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DatabaseService_Register_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DatabaseUser)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DatabaseServiceServer).Register(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DatabaseService_Deregister_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DatabaseUser)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DatabaseServiceServer).Deregister(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DatabaseService_Verify_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DatabaseUser_Verify)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DatabaseServiceServer).Verify(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _DatabaseService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.DatabaseService",
	HandlerType: (*DatabaseServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Query",
			Handler:    _DatabaseService_Query_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _DatabaseService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _DatabaseService_Update_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _DatabaseService_Register_Handler,
		},
		{
			MethodName: "Deregister",
			Handler:    _DatabaseService_Deregister_Handler,
		},
		{
			MethodName: "Verify",
			Handler:    _DatabaseService_Verify_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for AudioService service

type AudioServiceClient interface {
	SetRedirectWhisperGroup(ctx context.Context, in *RedirectWhisperGroup, opts ...grpc.CallOption) (*Void, error)
}

type audioServiceClient struct {
	cc *grpc.ClientConn
}

func NewAudioServiceClient(cc *grpc.ClientConn) AudioServiceClient {
	return &audioServiceClient{cc}
}

func (c *audioServiceClient) SetRedirectWhisperGroup(ctx context.Context, in *RedirectWhisperGroup, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.AudioService/SetRedirectWhisperGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AudioService service

type AudioServiceServer interface {
	SetRedirectWhisperGroup(context.Context, *RedirectWhisperGroup) (*Void, error)
}

func RegisterAudioServiceServer(s *grpc.Server, srv AudioServiceServer) {
	s.RegisterService(&_AudioService_serviceDesc, srv)
}

func _AudioService_SetRedirectWhisperGroup_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RedirectWhisperGroup)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(AudioServiceServer).SetRedirectWhisperGroup(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _AudioService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.AudioService",
	HandlerType: (*AudioServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetRedirectWhisperGroup",
			Handler:    _AudioService_SetRedirectWhisperGroup_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
