// Code generated by protoc-gen-go.
// source: MurmurRPC.proto
// DO NOT EDIT!

/*
Package MurmurRPC is a generated protocol buffer package.

It is generated from these files:
	MurmurRPC.proto

It has these top-level messages:
	Void
	Version
	Uptime
	Server
	Event
	ContextAction
	TextMessage
	Log
	Config
	Channel
	User
	Tree
	Ban
	ACL
	Authenticator
	DatabaseUser
	RedirectWhisperGroup
*/
package MurmurRPC

import proto "github.com/golang/protobuf/proto"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type Server_Event_Type int32

const (
	Server_Event_UserConnected       Server_Event_Type = 0
	Server_Event_UserDisconnected    Server_Event_Type = 1
	Server_Event_UserStateChanged    Server_Event_Type = 2
	Server_Event_UserTextMessage     Server_Event_Type = 3
	Server_Event_ChannelCreated      Server_Event_Type = 4
	Server_Event_ChannelRemoved      Server_Event_Type = 5
	Server_Event_ChannelStateChanged Server_Event_Type = 6
)

var Server_Event_Type_name = map[int32]string{
	0: "UserConnected",
	1: "UserDisconnected",
	2: "UserStateChanged",
	3: "UserTextMessage",
	4: "ChannelCreated",
	5: "ChannelRemoved",
	6: "ChannelStateChanged",
}
var Server_Event_Type_value = map[string]int32{
	"UserConnected":       0,
	"UserDisconnected":    1,
	"UserStateChanged":    2,
	"UserTextMessage":     3,
	"ChannelCreated":      4,
	"ChannelRemoved":      5,
	"ChannelStateChanged": 6,
}

func (x Server_Event_Type) Enum() *Server_Event_Type {
	p := new(Server_Event_Type)
	*p = x
	return p
}
func (x Server_Event_Type) String() string {
	return proto.EnumName(Server_Event_Type_name, int32(x))
}
func (x *Server_Event_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Server_Event_Type_value, data, "Server_Event_Type")
	if err != nil {
		return err
	}
	*x = Server_Event_Type(value)
	return nil
}

type Event_Type int32

const (
	Event_ServerStopped Event_Type = 0
	Event_ServerStarted Event_Type = 1
)

var Event_Type_name = map[int32]string{
	0: "ServerStopped",
	1: "ServerStarted",
}
var Event_Type_value = map[string]int32{
	"ServerStopped": 0,
	"ServerStarted": 1,
}

func (x Event_Type) Enum() *Event_Type {
	p := new(Event_Type)
	*p = x
	return p
}
func (x Event_Type) String() string {
	return proto.EnumName(Event_Type_name, int32(x))
}
func (x *Event_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Event_Type_value, data, "Event_Type")
	if err != nil {
		return err
	}
	*x = Event_Type(value)
	return nil
}

type ContextAction_Context int32

const (
	ContextAction_None    ContextAction_Context = 0
	ContextAction_Server  ContextAction_Context = 1
	ContextAction_Channel ContextAction_Context = 2
	ContextAction_User    ContextAction_Context = 4
)

var ContextAction_Context_name = map[int32]string{
	0: "None",
	1: "Server",
	2: "Channel",
	4: "User",
}
var ContextAction_Context_value = map[string]int32{
	"None":    0,
	"Server":  1,
	"Channel": 2,
	"User":    4,
}

func (x ContextAction_Context) Enum() *ContextAction_Context {
	p := new(ContextAction_Context)
	*p = x
	return p
}
func (x ContextAction_Context) String() string {
	return proto.EnumName(ContextAction_Context_name, int32(x))
}
func (x *ContextAction_Context) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ContextAction_Context_value, data, "ContextAction_Context")
	if err != nil {
		return err
	}
	*x = ContextAction_Context(value)
	return nil
}

type ACL_Permission int32

const (
	ACL_None                 ACL_Permission = 0
	ACL_Write                ACL_Permission = 1
	ACL_Traverse             ACL_Permission = 2
	ACL_Enter                ACL_Permission = 4
	ACL_Speak                ACL_Permission = 8
	ACL_Whisper              ACL_Permission = 256
	ACL_MuteDeafen           ACL_Permission = 16
	ACL_Move                 ACL_Permission = 32
	ACL_MakeChannel          ACL_Permission = 64
	ACL_MakeTemporaryChannel ACL_Permission = 1024
	ACL_LinkChannel          ACL_Permission = 128
	ACL_TextMessage          ACL_Permission = 512
	ACL_Kick                 ACL_Permission = 65536
	ACL_Ban                  ACL_Permission = 131072
	ACL_Register             ACL_Permission = 262144
	ACL_RegisterSelf         ACL_Permission = 524288
)

var ACL_Permission_name = map[int32]string{
	0:      "None",
	1:      "Write",
	2:      "Traverse",
	4:      "Enter",
	8:      "Speak",
	256:    "Whisper",
	16:     "MuteDeafen",
	32:     "Move",
	64:     "MakeChannel",
	1024:   "MakeTemporaryChannel",
	128:    "LinkChannel",
	512:    "TextMessage",
	65536:  "Kick",
	131072: "Ban",
	262144: "Register",
	524288: "RegisterSelf",
}
var ACL_Permission_value = map[string]int32{
	"None":                 0,
	"Write":                1,
	"Traverse":             2,
	"Enter":                4,
	"Speak":                8,
	"Whisper":              256,
	"MuteDeafen":           16,
	"Move":                 32,
	"MakeChannel":          64,
	"MakeTemporaryChannel": 1024,
	"LinkChannel":          128,
	"TextMessage":          512,
	"Kick":                 65536,
	"Ban":                  131072,
	"Register":             262144,
	"RegisterSelf":         524288,
}

func (x ACL_Permission) Enum() *ACL_Permission {
	p := new(ACL_Permission)
	*p = x
	return p
}
func (x ACL_Permission) String() string {
	return proto.EnumName(ACL_Permission_name, int32(x))
}
func (x *ACL_Permission) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ACL_Permission_value, data, "ACL_Permission")
	if err != nil {
		return err
	}
	*x = ACL_Permission(value)
	return nil
}

type Authenticator_Response_Status int32

const (
	Authenticator_Response_Fallthrough      Authenticator_Response_Status = 0
	Authenticator_Response_Success          Authenticator_Response_Status = 1
	Authenticator_Response_Failure          Authenticator_Response_Status = 2
	Authenticator_Response_TemporaryFailure Authenticator_Response_Status = 3
)

var Authenticator_Response_Status_name = map[int32]string{
	0: "Fallthrough",
	1: "Success",
	2: "Failure",
	3: "TemporaryFailure",
}
var Authenticator_Response_Status_value = map[string]int32{
	"Fallthrough":      0,
	"Success":          1,
	"Failure":          2,
	"TemporaryFailure": 3,
}

func (x Authenticator_Response_Status) Enum() *Authenticator_Response_Status {
	p := new(Authenticator_Response_Status)
	*p = x
	return p
}
func (x Authenticator_Response_Status) String() string {
	return proto.EnumName(Authenticator_Response_Status_name, int32(x))
}
func (x *Authenticator_Response_Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Authenticator_Response_Status_value, data, "Authenticator_Response_Status")
	if err != nil {
		return err
	}
	*x = Authenticator_Response_Status(value)
	return nil
}

type Void struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Void) Reset()         { *m = Void{} }
func (m *Void) String() string { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()    {}

type Version struct {
	// 2-byte Major, 1-byte Minor and 1-byte Patch version number.
	Version *uint32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	// Client release name.
	Release *string `protobuf:"bytes,2,opt,name=release" json:"release,omitempty"`
	// Client OS name.
	Os *string `protobuf:"bytes,3,opt,name=os" json:"os,omitempty"`
	// Client OS version.
	OsVersion        *string `protobuf:"bytes,4,opt,name=os_version" json:"os_version,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Version) Reset()         { *m = Version{} }
func (m *Version) String() string { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()    {}

func (m *Version) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *Version) GetRelease() string {
	if m != nil && m.Release != nil {
		return *m.Release
	}
	return ""
}

func (m *Version) GetOs() string {
	if m != nil && m.Os != nil {
		return *m.Os
	}
	return ""
}

func (m *Version) GetOsVersion() string {
	if m != nil && m.OsVersion != nil {
		return *m.OsVersion
	}
	return ""
}

type Uptime struct {
	// The number of seconds from the starting time.
	Secs             *uint64 `protobuf:"varint,1,opt,name=secs" json:"secs,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Uptime) Reset()         { *m = Uptime{} }
func (m *Uptime) String() string { return proto.CompactTextString(m) }
func (*Uptime) ProtoMessage()    {}

func (m *Uptime) GetSecs() uint64 {
	if m != nil && m.Secs != nil {
		return *m.Secs
	}
	return 0
}

type Server struct {
	// The unique server ID.
	Id *uint32 `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
	// Is the server currently running?
	Running *bool `protobuf:"varint,2,opt,name=running" json:"running,omitempty"`
	// The update of the server.
	Uptime           *Uptime `protobuf:"bytes,3,opt,name=uptime" json:"uptime,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Server) Reset()         { *m = Server{} }
func (m *Server) String() string { return proto.CompactTextString(m) }
func (*Server) ProtoMessage()    {}

func (m *Server) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Server) GetRunning() bool {
	if m != nil && m.Running != nil {
		return *m.Running
	}
	return false
}

func (m *Server) GetUptime() *Uptime {
	if m != nil {
		return m.Uptime
	}
	return nil
}

type Server_Event struct {
	// The server on which the event happened.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The type of event that happened.
	Type *Server_Event_Type `protobuf:"varint,2,opt,name=type,enum=MurmurRPC.Server_Event_Type" json:"type,omitempty"`
	// The user tied to the event (if applicable).
	User *User `protobuf:"bytes,3,opt,name=user" json:"user,omitempty"`
	// The text message tied to the event (if applicable).
	Message *TextMessage `protobuf:"bytes,4,opt,name=message" json:"message,omitempty"`
	// The channel tied to the event (if applicable).
	Channel          *Channel `protobuf:"bytes,5,opt,name=channel" json:"channel,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Server_Event) Reset()         { *m = Server_Event{} }
func (m *Server_Event) String() string { return proto.CompactTextString(m) }
func (*Server_Event) ProtoMessage()    {}

func (m *Server_Event) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Server_Event) GetType() Server_Event_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Server_Event_UserConnected
}

func (m *Server_Event) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Server_Event) GetMessage() *TextMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Server_Event) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

type Server_Query struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Server_Query) Reset()         { *m = Server_Query{} }
func (m *Server_Query) String() string { return proto.CompactTextString(m) }
func (*Server_Query) ProtoMessage()    {}

type Server_List struct {
	// The servers.
	Servers          []*Server `protobuf:"bytes,1,rep,name=servers" json:"servers,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Server_List) Reset()         { *m = Server_List{} }
func (m *Server_List) String() string { return proto.CompactTextString(m) }
func (*Server_List) ProtoMessage()    {}

func (m *Server_List) GetServers() []*Server {
	if m != nil {
		return m.Servers
	}
	return nil
}

type Event struct {
	// The server for which the event happened.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The type of event that happened.
	Type             *Event_Type `protobuf:"varint,2,opt,name=type,enum=MurmurRPC.Event_Type" json:"type,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}

func (m *Event) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Event) GetType() Event_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Event_ServerStopped
}

type ContextAction struct {
	// The server on which the action is.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The context in which the action is.
	Context *ContextAction_Context `protobuf:"varint,2,opt,name=context,enum=MurmurRPC.ContextAction_Context" json:"context,omitempty"`
	// The action name.
	Action *string `protobuf:"bytes,3,opt,name=action" json:"action,omitempty"`
	// The user-visible descriptive name of the action.
	Text *string `protobuf:"bytes,4,opt,name=text" json:"text,omitempty"`
	// The user that triggered the ContextAction.
	Actor *User `protobuf:"bytes,5,opt,name=actor" json:"actor,omitempty"`
	// The user on which the ContextAction was triggered.
	User *User `protobuf:"bytes,6,opt,name=user" json:"user,omitempty"`
	// The channel on which the ContextAction was triggered.
	Channel          *Channel `protobuf:"bytes,7,opt,name=channel" json:"channel,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ContextAction) Reset()         { *m = ContextAction{} }
func (m *ContextAction) String() string { return proto.CompactTextString(m) }
func (*ContextAction) ProtoMessage()    {}

func (m *ContextAction) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *ContextAction) GetContext() ContextAction_Context {
	if m != nil && m.Context != nil {
		return *m.Context
	}
	return ContextAction_None
}

func (m *ContextAction) GetAction() string {
	if m != nil && m.Action != nil {
		return *m.Action
	}
	return ""
}

func (m *ContextAction) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

func (m *ContextAction) GetActor() *User {
	if m != nil {
		return m.Actor
	}
	return nil
}

func (m *ContextAction) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ContextAction) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

type TextMessage struct {
	// The server on which the TextMessage originates.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The user who sent the message.
	Actor *User `protobuf:"bytes,2,opt,name=actor" json:"actor,omitempty"`
	// The users to whom the message is sent.
	Users []*User `protobuf:"bytes,3,rep,name=users" json:"users,omitempty"`
	// The channels to which the message is sent.
	Channels []*Channel `protobuf:"bytes,4,rep,name=channels" json:"channels,omitempty"`
	// The channels to which the message is sent, including the channels'
	// ancestors.
	Trees []*Channel `protobuf:"bytes,5,rep,name=trees" json:"trees,omitempty"`
	// The message body that is sent.
	Text             *string `protobuf:"bytes,6,opt,name=text" json:"text,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TextMessage) Reset()         { *m = TextMessage{} }
func (m *TextMessage) String() string { return proto.CompactTextString(m) }
func (*TextMessage) ProtoMessage()    {}

func (m *TextMessage) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *TextMessage) GetActor() *User {
	if m != nil {
		return m.Actor
	}
	return nil
}

func (m *TextMessage) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *TextMessage) GetChannels() []*Channel {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *TextMessage) GetTrees() []*Channel {
	if m != nil {
		return m.Trees
	}
	return nil
}

func (m *TextMessage) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

type Log struct {
	// The server on which the log message was generated.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The unix timestamp of when the message was generated.
	Timestamp *int64 `protobuf:"varint,2,opt,name=timestamp" json:"timestamp,omitempty"`
	// The log message.
	Text             *string `protobuf:"bytes,3,opt,name=text" json:"text,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Log) Reset()         { *m = Log{} }
func (m *Log) String() string { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()    {}

func (m *Log) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Log) GetTimestamp() int64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *Log) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

type Log_Query struct {
	// The server whose logs will be queried.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The minimum log index to receive.
	Min *uint32 `protobuf:"varint,2,opt,name=min" json:"min,omitempty"`
	// The maximum log index to receive.
	Max              *uint32 `protobuf:"varint,3,opt,name=max" json:"max,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Log_Query) Reset()         { *m = Log_Query{} }
func (m *Log_Query) String() string { return proto.CompactTextString(m) }
func (*Log_Query) ProtoMessage()    {}

func (m *Log_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Log_Query) GetMin() uint32 {
	if m != nil && m.Min != nil {
		return *m.Min
	}
	return 0
}

func (m *Log_Query) GetMax() uint32 {
	if m != nil && m.Max != nil {
		return *m.Max
	}
	return 0
}

type Log_List struct {
	// The server where the log entries are from.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The total number of logs entries on the server.
	Total *uint32 `protobuf:"varint,2,opt,name=total" json:"total,omitempty"`
	// The minimum log index that was sent.
	Min *uint32 `protobuf:"varint,3,opt,name=min" json:"min,omitempty"`
	// The maximum log index that was sent.
	Max *uint32 `protobuf:"varint,4,opt,name=max" json:"max,omitempty"`
	// The log entries.
	Entries          []*Log `protobuf:"bytes,5,rep,name=entries" json:"entries,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Log_List) Reset()         { *m = Log_List{} }
func (m *Log_List) String() string { return proto.CompactTextString(m) }
func (*Log_List) ProtoMessage()    {}

func (m *Log_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Log_List) GetTotal() uint32 {
	if m != nil && m.Total != nil {
		return *m.Total
	}
	return 0
}

func (m *Log_List) GetMin() uint32 {
	if m != nil && m.Min != nil {
		return *m.Min
	}
	return 0
}

func (m *Log_List) GetMax() uint32 {
	if m != nil && m.Max != nil {
		return *m.Max
	}
	return 0
}

func (m *Log_List) GetEntries() []*Log {
	if m != nil {
		return m.Entries
	}
	return nil
}

type Config struct {
	// The server for which the configuration is for.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The configuration keys and values.
	Fields           map[string]string `protobuf:"bytes,2,rep,name=fields" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *Config) Reset()         { *m = Config{} }
func (m *Config) String() string { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()    {}

func (m *Config) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Config) GetFields() map[string]string {
	if m != nil {
		return m.Fields
	}
	return nil
}

type Config_Field struct {
	// The server for which the configuration field is for.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The field key.
	Key *string `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	// The field value.
	Value            *string `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Config_Field) Reset()         { *m = Config_Field{} }
func (m *Config_Field) String() string { return proto.CompactTextString(m) }
func (*Config_Field) ProtoMessage()    {}

func (m *Config_Field) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Config_Field) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *Config_Field) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type Channel struct {
	// The server on which the channel exists.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The unique channel identifier.
	Id *uint32 `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	// The channel name.
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// The channel's parent.
	Parent *Channel `protobuf:"bytes,4,opt,name=parent" json:"parent,omitempty"`
	// Linked channels.
	Links []*Channel `protobuf:"bytes,5,rep,name=links" json:"links,omitempty"`
	// The channel's description.
	Description *string `protobuf:"bytes,6,opt,name=description" json:"description,omitempty"`
	// Is the channel temporary?
	Temporary *bool `protobuf:"varint,7,opt,name=temporary" json:"temporary,omitempty"`
	// The position in which the channel should appear in a sorted list.
	Position         *int32 `protobuf:"varint,8,opt,name=position" json:"position,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Channel) Reset()         { *m = Channel{} }
func (m *Channel) String() string { return proto.CompactTextString(m) }
func (*Channel) ProtoMessage()    {}

func (m *Channel) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Channel) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Channel) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Channel) GetParent() *Channel {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *Channel) GetLinks() []*Channel {
	if m != nil {
		return m.Links
	}
	return nil
}

func (m *Channel) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *Channel) GetTemporary() bool {
	if m != nil && m.Temporary != nil {
		return *m.Temporary
	}
	return false
}

func (m *Channel) GetPosition() int32 {
	if m != nil && m.Position != nil {
		return *m.Position
	}
	return 0
}

type Channel_Query struct {
	// The server on which the channels are.
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Channel_Query) Reset()         { *m = Channel_Query{} }
func (m *Channel_Query) String() string { return proto.CompactTextString(m) }
func (*Channel_Query) ProtoMessage()    {}

func (m *Channel_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

type Channel_List struct {
	// The server on which the channels are.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The channels.
	Channels         []*Channel `protobuf:"bytes,2,rep,name=channels" json:"channels,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *Channel_List) Reset()         { *m = Channel_List{} }
func (m *Channel_List) String() string { return proto.CompactTextString(m) }
func (*Channel_List) ProtoMessage()    {}

func (m *Channel_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Channel_List) GetChannels() []*Channel {
	if m != nil {
		return m.Channels
	}
	return nil
}

type User struct {
	// The server to which the user is connected.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The user's session ID.
	Session *uint32 `protobuf:"varint,2,opt,name=session" json:"session,omitempty"`
	// The user's registered ID.
	Id *uint32 `protobuf:"varint,3,opt,name=id" json:"id,omitempty"`
	// The user's name.
	Name *string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	// Is the user muted?
	Mute *bool `protobuf:"varint,5,opt,name=mute" json:"mute,omitempty"`
	// Is the user deafened?
	Deaf *bool `protobuf:"varint,6,opt,name=deaf" json:"deaf,omitempty"`
	// Is the user suppressed?
	Suppress *bool `protobuf:"varint,7,opt,name=suppress" json:"suppress,omitempty"`
	// Is the user a priority speaker?
	PrioritySpeaker *bool `protobuf:"varint,8,opt,name=priority_speaker" json:"priority_speaker,omitempty"`
	// Has the user muted him/herself?
	SelfMute *bool `protobuf:"varint,9,opt,name=self_mute" json:"self_mute,omitempty"`
	// Has the user muted him/herself?
	SelfDeaf *bool `protobuf:"varint,10,opt,name=self_deaf" json:"self_deaf,omitempty"`
	// Is the user recording?
	Recording *bool `protobuf:"varint,11,opt,name=recording" json:"recording,omitempty"`
	// The channel the user is in.
	Channel *Channel `protobuf:"bytes,12,opt,name=channel" json:"channel,omitempty"`
	// How long the user has been connected to the server.
	OnlineSecs *uint32 `protobuf:"varint,13,opt,name=online_secs" json:"online_secs,omitempty"`
	// How long the user has been idle on the server.
	IdleSecs *uint32 `protobuf:"varint,14,opt,name=idle_secs" json:"idle_secs,omitempty"`
	// How many bytes per second is the user transmitting to the server.
	BytesPerSec *uint32 `protobuf:"varint,15,opt,name=bytes_per_sec" json:"bytes_per_sec,omitempty"`
	// The user's client version.
	Version *Version `protobuf:"bytes,16,opt,name=version" json:"version,omitempty"`
	// The user's  plugin context.
	PluginContext []byte `protobuf:"bytes,17,opt,name=plugin_context" json:"plugin_context,omitempty"`
	// The user's plugin identity.
	PluginIdentity *string `protobuf:"bytes,18,opt,name=plugin_identity" json:"plugin_identity,omitempty"`
	// The user's comment.
	Comment *string `protobuf:"bytes,19,opt,name=comment" json:"comment,omitempty"`
	// The user's texture.
	Texture []byte `protobuf:"bytes,20,opt,name=texture" json:"texture,omitempty"`
	// The user's IP address.
	Address []byte `protobuf:"bytes,21,opt,name=address" json:"address,omitempty"`
	// Is the user in TCP-only mode?
	TcpOnly *bool `protobuf:"varint,22,opt,name=tcp_only" json:"tcp_only,omitempty"`
	// The user's UDP ping in milliseconds.
	UdpPingMsecs *float32 `protobuf:"fixed32,23,opt,name=udp_ping_msecs" json:"udp_ping_msecs,omitempty"`
	// The user's TCP ping in milliseconds.
	TcpPingMsecs     *float32 `protobuf:"fixed32,24,opt,name=tcp_ping_msecs" json:"tcp_ping_msecs,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}

func (m *User) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *User) GetSession() uint32 {
	if m != nil && m.Session != nil {
		return *m.Session
	}
	return 0
}

func (m *User) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *User) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *User) GetMute() bool {
	if m != nil && m.Mute != nil {
		return *m.Mute
	}
	return false
}

func (m *User) GetDeaf() bool {
	if m != nil && m.Deaf != nil {
		return *m.Deaf
	}
	return false
}

func (m *User) GetSuppress() bool {
	if m != nil && m.Suppress != nil {
		return *m.Suppress
	}
	return false
}

func (m *User) GetPrioritySpeaker() bool {
	if m != nil && m.PrioritySpeaker != nil {
		return *m.PrioritySpeaker
	}
	return false
}

func (m *User) GetSelfMute() bool {
	if m != nil && m.SelfMute != nil {
		return *m.SelfMute
	}
	return false
}

func (m *User) GetSelfDeaf() bool {
	if m != nil && m.SelfDeaf != nil {
		return *m.SelfDeaf
	}
	return false
}

func (m *User) GetRecording() bool {
	if m != nil && m.Recording != nil {
		return *m.Recording
	}
	return false
}

func (m *User) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *User) GetOnlineSecs() uint32 {
	if m != nil && m.OnlineSecs != nil {
		return *m.OnlineSecs
	}
	return 0
}

func (m *User) GetIdleSecs() uint32 {
	if m != nil && m.IdleSecs != nil {
		return *m.IdleSecs
	}
	return 0
}

func (m *User) GetBytesPerSec() uint32 {
	if m != nil && m.BytesPerSec != nil {
		return *m.BytesPerSec
	}
	return 0
}

func (m *User) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *User) GetPluginContext() []byte {
	if m != nil {
		return m.PluginContext
	}
	return nil
}

func (m *User) GetPluginIdentity() string {
	if m != nil && m.PluginIdentity != nil {
		return *m.PluginIdentity
	}
	return ""
}

func (m *User) GetComment() string {
	if m != nil && m.Comment != nil {
		return *m.Comment
	}
	return ""
}

func (m *User) GetTexture() []byte {
	if m != nil {
		return m.Texture
	}
	return nil
}

func (m *User) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *User) GetTcpOnly() bool {
	if m != nil && m.TcpOnly != nil {
		return *m.TcpOnly
	}
	return false
}

func (m *User) GetUdpPingMsecs() float32 {
	if m != nil && m.UdpPingMsecs != nil {
		return *m.UdpPingMsecs
	}
	return 0
}

func (m *User) GetTcpPingMsecs() float32 {
	if m != nil && m.TcpPingMsecs != nil {
		return *m.TcpPingMsecs
	}
	return 0
}

type User_Query struct {
	// The server whose users will be queried.
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *User_Query) Reset()         { *m = User_Query{} }
func (m *User_Query) String() string { return proto.CompactTextString(m) }
func (*User_Query) ProtoMessage()    {}

func (m *User_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

type User_List struct {
	// The server to which the users are connected.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The users.
	Users            []*User `protobuf:"bytes,2,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *User_List) Reset()         { *m = User_List{} }
func (m *User_List) String() string { return proto.CompactTextString(m) }
func (*User_List) ProtoMessage()    {}

func (m *User_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *User_List) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

type User_Kick struct {
	// The server to which the user is connected.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The user to kick.
	User *User `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	// The user who performed the kick.
	Actor *User `protobuf:"bytes,3,opt,name=actor" json:"actor,omitempty"`
	// The reason for why the user is being kicked.
	Reason           *string `protobuf:"bytes,4,opt,name=reason" json:"reason,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *User_Kick) Reset()         { *m = User_Kick{} }
func (m *User_Kick) String() string { return proto.CompactTextString(m) }
func (*User_Kick) ProtoMessage()    {}

func (m *User_Kick) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *User_Kick) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *User_Kick) GetActor() *User {
	if m != nil {
		return m.Actor
	}
	return nil
}

func (m *User_Kick) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

type Tree struct {
	// The server which the tree represents.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The current channel.
	Channel *Channel `protobuf:"bytes,2,opt,name=channel" json:"channel,omitempty"`
	// Channels below the current channel.
	Children []*Tree `protobuf:"bytes,3,rep,name=children" json:"children,omitempty"`
	// The users in the current channel.
	Users            []*User `protobuf:"bytes,4,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Tree) Reset()         { *m = Tree{} }
func (m *Tree) String() string { return proto.CompactTextString(m) }
func (*Tree) ProtoMessage()    {}

func (m *Tree) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Tree) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *Tree) GetChildren() []*Tree {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Tree) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

type Tree_Query struct {
	// The server to query.
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Tree_Query) Reset()         { *m = Tree_Query{} }
func (m *Tree_Query) String() string { return proto.CompactTextString(m) }
func (*Tree_Query) ProtoMessage()    {}

func (m *Tree_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

type Ban struct {
	// The server on which the ban is applied.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The banned IP address.
	Address []byte `protobuf:"bytes,2,opt,name=address" json:"address,omitempty"`
	// The number of leading bits in the address to which the ban applies.
	Bits *uint32 `protobuf:"varint,3,opt,name=bits" json:"bits,omitempty"`
	// The name of the banned user.
	Name *string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	// The certificate hash of the banned user.
	Hash *string `protobuf:"bytes,5,opt,name=hash" json:"hash,omitempty"`
	// The reason for the ban.
	Reason *string `protobuf:"bytes,6,opt,name=reason" json:"reason,omitempty"`
	// The ban start time (in epoch form).
	Start *int64 `protobuf:"varint,7,opt,name=start" json:"start,omitempty"`
	// The ban duration.
	DurationSecs     *int64 `protobuf:"varint,8,opt,name=duration_secs" json:"duration_secs,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Ban) Reset()         { *m = Ban{} }
func (m *Ban) String() string { return proto.CompactTextString(m) }
func (*Ban) ProtoMessage()    {}

func (m *Ban) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Ban) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *Ban) GetBits() uint32 {
	if m != nil && m.Bits != nil {
		return *m.Bits
	}
	return 0
}

func (m *Ban) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Ban) GetHash() string {
	if m != nil && m.Hash != nil {
		return *m.Hash
	}
	return ""
}

func (m *Ban) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

func (m *Ban) GetStart() int64 {
	if m != nil && m.Start != nil {
		return *m.Start
	}
	return 0
}

func (m *Ban) GetDurationSecs() int64 {
	if m != nil && m.DurationSecs != nil {
		return *m.DurationSecs
	}
	return 0
}

type Ban_Query struct {
	// The server whose bans to query.
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Ban_Query) Reset()         { *m = Ban_Query{} }
func (m *Ban_Query) String() string { return proto.CompactTextString(m) }
func (*Ban_Query) ProtoMessage()    {}

func (m *Ban_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

type Ban_List struct {
	// The server for which the bans apply.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The bans.
	Bans             []*Ban `protobuf:"bytes,2,rep,name=bans" json:"bans,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Ban_List) Reset()         { *m = Ban_List{} }
func (m *Ban_List) String() string { return proto.CompactTextString(m) }
func (*Ban_List) ProtoMessage()    {}

func (m *Ban_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Ban_List) GetBans() []*Ban {
	if m != nil {
		return m.Bans
	}
	return nil
}

type ACL struct {
	// Does the ACL apply to the current channel?
	ApplyHere *bool `protobuf:"varint,3,opt,name=apply_here" json:"apply_here,omitempty"`
	// Does the ACL apply to the current channel's sub-channels?
	ApplySubs *bool `protobuf:"varint,4,opt,name=apply_subs" json:"apply_subs,omitempty"`
	// Was the ACL inherited?
	Inherited *bool `protobuf:"varint,5,opt,name=inherited" json:"inherited,omitempty"`
	// The user to whom the ACL applies.
	User *DatabaseUser `protobuf:"bytes,6,opt,name=user" json:"user,omitempty"`
	// The group to whom the ACL applies.
	Group *ACL_Group `protobuf:"bytes,7,opt,name=group" json:"group,omitempty"`
	// The permissions granted by the ACL.
	Allow *ACL_Permission `protobuf:"varint,8,opt,name=allow,enum=MurmurRPC.ACL_Permission" json:"allow,omitempty"`
	// The permissions denied by the ACL.
	Deny             *ACL_Permission `protobuf:"varint,9,opt,name=deny,enum=MurmurRPC.ACL_Permission" json:"deny,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *ACL) Reset()         { *m = ACL{} }
func (m *ACL) String() string { return proto.CompactTextString(m) }
func (*ACL) ProtoMessage()    {}

func (m *ACL) GetApplyHere() bool {
	if m != nil && m.ApplyHere != nil {
		return *m.ApplyHere
	}
	return false
}

func (m *ACL) GetApplySubs() bool {
	if m != nil && m.ApplySubs != nil {
		return *m.ApplySubs
	}
	return false
}

func (m *ACL) GetInherited() bool {
	if m != nil && m.Inherited != nil {
		return *m.Inherited
	}
	return false
}

func (m *ACL) GetUser() *DatabaseUser {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ACL) GetGroup() *ACL_Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *ACL) GetAllow() ACL_Permission {
	if m != nil && m.Allow != nil {
		return *m.Allow
	}
	return ACL_None
}

func (m *ACL) GetDeny() ACL_Permission {
	if m != nil && m.Deny != nil {
		return *m.Deny
	}
	return ACL_None
}

type ACL_Group struct {
	// The ACL group name.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Is the group inherited?
	Inherited *bool `protobuf:"varint,2,opt,name=inherited" json:"inherited,omitempty"`
	// Does the group inherit members?
	Inherit *bool `protobuf:"varint,3,opt,name=inherit" json:"inherit,omitempty"`
	// Can this group be inherited by its children?
	Inheritable *bool `protobuf:"varint,4,opt,name=inheritable" json:"inheritable,omitempty"`
	// The users explicitly added by this group.
	UsersAdd []*DatabaseUser `protobuf:"bytes,5,rep,name=users_add" json:"users_add,omitempty"`
	// The users explicitly removed by this group.
	UsersRemove []*DatabaseUser `protobuf:"bytes,6,rep,name=users_remove" json:"users_remove,omitempty"`
	// All of the users who are part of this group.
	Users            []*DatabaseUser `protobuf:"bytes,7,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *ACL_Group) Reset()         { *m = ACL_Group{} }
func (m *ACL_Group) String() string { return proto.CompactTextString(m) }
func (*ACL_Group) ProtoMessage()    {}

func (m *ACL_Group) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ACL_Group) GetInherited() bool {
	if m != nil && m.Inherited != nil {
		return *m.Inherited
	}
	return false
}

func (m *ACL_Group) GetInherit() bool {
	if m != nil && m.Inherit != nil {
		return *m.Inherit
	}
	return false
}

func (m *ACL_Group) GetInheritable() bool {
	if m != nil && m.Inheritable != nil {
		return *m.Inheritable
	}
	return false
}

func (m *ACL_Group) GetUsersAdd() []*DatabaseUser {
	if m != nil {
		return m.UsersAdd
	}
	return nil
}

func (m *ACL_Group) GetUsersRemove() []*DatabaseUser {
	if m != nil {
		return m.UsersRemove
	}
	return nil
}

func (m *ACL_Group) GetUsers() []*DatabaseUser {
	if m != nil {
		return m.Users
	}
	return nil
}

type ACL_Query struct {
	// The server where the user and channel exist.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The user to query.
	User *User `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	// The channel to query.
	Channel          *Channel `protobuf:"bytes,3,opt,name=channel" json:"channel,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ACL_Query) Reset()         { *m = ACL_Query{} }
func (m *ACL_Query) String() string { return proto.CompactTextString(m) }
func (*ACL_Query) ProtoMessage()    {}

func (m *ACL_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *ACL_Query) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ACL_Query) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

type ACL_List struct {
	// The server on which the ACLs exist.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The channel to which the ACL refers.
	Channel *Channel `protobuf:"bytes,2,opt,name=channel" json:"channel,omitempty"`
	// The ACLs part of the given channel.
	Acls []*ACL `protobuf:"bytes,3,rep,name=acls" json:"acls,omitempty"`
	// The groups part of the given channel.
	Groups []*ACL_Group `protobuf:"bytes,4,rep,name=groups" json:"groups,omitempty"`
	// Should ACLs be inherited from the parent channel.
	Inherit          *bool  `protobuf:"varint,5,opt,name=inherit" json:"inherit,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ACL_List) Reset()         { *m = ACL_List{} }
func (m *ACL_List) String() string { return proto.CompactTextString(m) }
func (*ACL_List) ProtoMessage()    {}

func (m *ACL_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *ACL_List) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *ACL_List) GetAcls() []*ACL {
	if m != nil {
		return m.Acls
	}
	return nil
}

func (m *ACL_List) GetGroups() []*ACL_Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *ACL_List) GetInherit() bool {
	if m != nil && m.Inherit != nil {
		return *m.Inherit
	}
	return false
}

type ACL_TemporaryGroup struct {
	// The server where the temporary group exists.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The channel to which the temporary user group is added.
	Channel *Channel `protobuf:"bytes,2,opt,name=channel" json:"channel,omitempty"`
	// The user who is added to the group.
	User *User `protobuf:"bytes,3,opt,name=user" json:"user,omitempty"`
	// The name of the temporary group.
	Name             *string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ACL_TemporaryGroup) Reset()         { *m = ACL_TemporaryGroup{} }
func (m *ACL_TemporaryGroup) String() string { return proto.CompactTextString(m) }
func (*ACL_TemporaryGroup) ProtoMessage()    {}

func (m *ACL_TemporaryGroup) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *ACL_TemporaryGroup) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *ACL_TemporaryGroup) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ACL_TemporaryGroup) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

type Authenticator struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Authenticator) Reset()         { *m = Authenticator{} }
func (m *Authenticator) String() string { return proto.CompactTextString(m) }
func (*Authenticator) ProtoMessage()    {}

type Authenticator_Request struct {
	Authenticate     *Authenticator_Request_Authenticate `protobuf:"bytes,1,opt,name=authenticate" json:"authenticate,omitempty"`
	Find             *Authenticator_Request_Find         `protobuf:"bytes,2,opt,name=find" json:"find,omitempty"`
	Query            *Authenticator_Request_Query        `protobuf:"bytes,3,opt,name=query" json:"query,omitempty"`
	Register         *Authenticator_Request_Register     `protobuf:"bytes,4,opt,name=register" json:"register,omitempty"`
	Deregister       *Authenticator_Request_Deregister   `protobuf:"bytes,5,opt,name=deregister" json:"deregister,omitempty"`
	Update           *Authenticator_Request_Update       `protobuf:"bytes,6,opt,name=update" json:"update,omitempty"`
	XXX_unrecognized []byte                              `json:"-"`
}

func (m *Authenticator_Request) Reset()         { *m = Authenticator_Request{} }
func (m *Authenticator_Request) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request) ProtoMessage()    {}

func (m *Authenticator_Request) GetAuthenticate() *Authenticator_Request_Authenticate {
	if m != nil {
		return m.Authenticate
	}
	return nil
}

func (m *Authenticator_Request) GetFind() *Authenticator_Request_Find {
	if m != nil {
		return m.Find
	}
	return nil
}

func (m *Authenticator_Request) GetQuery() *Authenticator_Request_Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *Authenticator_Request) GetRegister() *Authenticator_Request_Register {
	if m != nil {
		return m.Register
	}
	return nil
}

func (m *Authenticator_Request) GetDeregister() *Authenticator_Request_Deregister {
	if m != nil {
		return m.Deregister
	}
	return nil
}

func (m *Authenticator_Request) GetUpdate() *Authenticator_Request_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

// An authentication request for a connecting user.
type Authenticator_Request_Authenticate struct {
	// The user's name.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The user's password.
	Password *string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
	// The user's certificate chain in DER format.
	Certificates [][]byte `protobuf:"bytes,3,rep,name=certificates" json:"certificates,omitempty"`
	// The hexadecimal hash of the user's certificate.
	CertificateHash *string `protobuf:"bytes,4,opt,name=certificate_hash" json:"certificate_hash,omitempty"`
	// If the user is connecting with a strong certificate.
	StrongCertificate *bool  `protobuf:"varint,5,opt,name=strong_certificate" json:"strong_certificate,omitempty"`
	XXX_unrecognized  []byte `json:"-"`
}

func (m *Authenticator_Request_Authenticate) Reset()         { *m = Authenticator_Request_Authenticate{} }
func (m *Authenticator_Request_Authenticate) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request_Authenticate) ProtoMessage()    {}

func (m *Authenticator_Request_Authenticate) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Authenticator_Request_Authenticate) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *Authenticator_Request_Authenticate) GetCertificates() [][]byte {
	if m != nil {
		return m.Certificates
	}
	return nil
}

func (m *Authenticator_Request_Authenticate) GetCertificateHash() string {
	if m != nil && m.CertificateHash != nil {
		return *m.CertificateHash
	}
	return ""
}

func (m *Authenticator_Request_Authenticate) GetStrongCertificate() bool {
	if m != nil && m.StrongCertificate != nil {
		return *m.StrongCertificate
	}
	return false
}

// A request for information about a user, given by either the user's ID
// or name.
type Authenticator_Request_Find struct {
	Id               *uint32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Name             *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Authenticator_Request_Find) Reset()         { *m = Authenticator_Request_Find{} }
func (m *Authenticator_Request_Find) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request_Find) ProtoMessage()    {}

func (m *Authenticator_Request_Find) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Authenticator_Request_Find) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

// A query of all the registered users, optionally filtered by the given
// filter string.
type Authenticator_Request_Query struct {
	Filter           *string `protobuf:"bytes,1,opt,name=filter" json:"filter,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Authenticator_Request_Query) Reset()         { *m = Authenticator_Request_Query{} }
func (m *Authenticator_Request_Query) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request_Query) ProtoMessage()    {}

func (m *Authenticator_Request_Query) GetFilter() string {
	if m != nil && m.Filter != nil {
		return *m.Filter
	}
	return ""
}

// A request for a new user registration.
type Authenticator_Request_Register struct {
	User             *DatabaseUser `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Authenticator_Request_Register) Reset()         { *m = Authenticator_Request_Register{} }
func (m *Authenticator_Request_Register) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request_Register) ProtoMessage()    {}

func (m *Authenticator_Request_Register) GetUser() *DatabaseUser {
	if m != nil {
		return m.User
	}
	return nil
}

// A request for deregistering a registered user.
type Authenticator_Request_Deregister struct {
	User             *DatabaseUser `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Authenticator_Request_Deregister) Reset()         { *m = Authenticator_Request_Deregister{} }
func (m *Authenticator_Request_Deregister) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request_Deregister) ProtoMessage()    {}

func (m *Authenticator_Request_Deregister) GetUser() *DatabaseUser {
	if m != nil {
		return m.User
	}
	return nil
}

// A request to update a registered user's information. The information
// provided should be merged with existing data.
type Authenticator_Request_Update struct {
	User             *DatabaseUser `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Authenticator_Request_Update) Reset()         { *m = Authenticator_Request_Update{} }
func (m *Authenticator_Request_Update) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request_Update) ProtoMessage()    {}

func (m *Authenticator_Request_Update) GetUser() *DatabaseUser {
	if m != nil {
		return m.User
	}
	return nil
}

type Authenticator_Response struct {
	Initialize       *Authenticator_Response_Initialize   `protobuf:"bytes,1,opt,name=initialize" json:"initialize,omitempty"`
	Authenticate     *Authenticator_Response_Authenticate `protobuf:"bytes,2,opt,name=authenticate" json:"authenticate,omitempty"`
	Find             *Authenticator_Response_Find         `protobuf:"bytes,3,opt,name=find" json:"find,omitempty"`
	Query            *Authenticator_Response_Query        `protobuf:"bytes,4,opt,name=query" json:"query,omitempty"`
	Register         *Authenticator_Response_Register     `protobuf:"bytes,5,opt,name=register" json:"register,omitempty"`
	Deregister       *Authenticator_Response_Deregister   `protobuf:"bytes,6,opt,name=deregister" json:"deregister,omitempty"`
	Update           *Authenticator_Response_Update       `protobuf:"bytes,7,opt,name=update" json:"update,omitempty"`
	XXX_unrecognized []byte                               `json:"-"`
}

func (m *Authenticator_Response) Reset()         { *m = Authenticator_Response{} }
func (m *Authenticator_Response) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response) ProtoMessage()    {}

func (m *Authenticator_Response) GetInitialize() *Authenticator_Response_Initialize {
	if m != nil {
		return m.Initialize
	}
	return nil
}

func (m *Authenticator_Response) GetAuthenticate() *Authenticator_Response_Authenticate {
	if m != nil {
		return m.Authenticate
	}
	return nil
}

func (m *Authenticator_Response) GetFind() *Authenticator_Response_Find {
	if m != nil {
		return m.Find
	}
	return nil
}

func (m *Authenticator_Response) GetQuery() *Authenticator_Response_Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *Authenticator_Response) GetRegister() *Authenticator_Response_Register {
	if m != nil {
		return m.Register
	}
	return nil
}

func (m *Authenticator_Response) GetDeregister() *Authenticator_Response_Deregister {
	if m != nil {
		return m.Deregister
	}
	return nil
}

func (m *Authenticator_Response) GetUpdate() *Authenticator_Response_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

// The initialization for the authenticator stream. This message must be
// sent before authentication requests will start streaming.
type Authenticator_Response_Initialize struct {
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Authenticator_Response_Initialize) Reset()         { *m = Authenticator_Response_Initialize{} }
func (m *Authenticator_Response_Initialize) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Initialize) ProtoMessage()    {}

func (m *Authenticator_Response_Initialize) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

type Authenticator_Response_Authenticate struct {
	Status           *Authenticator_Response_Status `protobuf:"varint,1,opt,name=status,enum=MurmurRPC.Authenticator_Response_Status" json:"status,omitempty"`
	Id               *uint32                        `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	Name             *string                        `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	Groups           []*ACL_Group                   `protobuf:"bytes,4,rep,name=groups" json:"groups,omitempty"`
	XXX_unrecognized []byte                         `json:"-"`
}

func (m *Authenticator_Response_Authenticate) Reset()         { *m = Authenticator_Response_Authenticate{} }
func (m *Authenticator_Response_Authenticate) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Authenticate) ProtoMessage()    {}

func (m *Authenticator_Response_Authenticate) GetStatus() Authenticator_Response_Status {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Authenticator_Response_Fallthrough
}

func (m *Authenticator_Response_Authenticate) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Authenticator_Response_Authenticate) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Authenticator_Response_Authenticate) GetGroups() []*ACL_Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

type Authenticator_Response_Find struct {
	User             *DatabaseUser `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Authenticator_Response_Find) Reset()         { *m = Authenticator_Response_Find{} }
func (m *Authenticator_Response_Find) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Find) ProtoMessage()    {}

func (m *Authenticator_Response_Find) GetUser() *DatabaseUser {
	if m != nil {
		return m.User
	}
	return nil
}

type Authenticator_Response_Query struct {
	Users            []*DatabaseUser `protobuf:"bytes,1,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Authenticator_Response_Query) Reset()         { *m = Authenticator_Response_Query{} }
func (m *Authenticator_Response_Query) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Query) ProtoMessage()    {}

func (m *Authenticator_Response_Query) GetUsers() []*DatabaseUser {
	if m != nil {
		return m.Users
	}
	return nil
}

type Authenticator_Response_Register struct {
	Status           *Authenticator_Response_Status `protobuf:"varint,1,opt,name=status,enum=MurmurRPC.Authenticator_Response_Status" json:"status,omitempty"`
	User             *DatabaseUser                  `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	XXX_unrecognized []byte                         `json:"-"`
}

func (m *Authenticator_Response_Register) Reset()         { *m = Authenticator_Response_Register{} }
func (m *Authenticator_Response_Register) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Register) ProtoMessage()    {}

func (m *Authenticator_Response_Register) GetStatus() Authenticator_Response_Status {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Authenticator_Response_Fallthrough
}

func (m *Authenticator_Response_Register) GetUser() *DatabaseUser {
	if m != nil {
		return m.User
	}
	return nil
}

type Authenticator_Response_Deregister struct {
	Status           *Authenticator_Response_Status `protobuf:"varint,1,opt,name=status,enum=MurmurRPC.Authenticator_Response_Status" json:"status,omitempty"`
	XXX_unrecognized []byte                         `json:"-"`
}

func (m *Authenticator_Response_Deregister) Reset()         { *m = Authenticator_Response_Deregister{} }
func (m *Authenticator_Response_Deregister) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Deregister) ProtoMessage()    {}

func (m *Authenticator_Response_Deregister) GetStatus() Authenticator_Response_Status {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Authenticator_Response_Fallthrough
}

type Authenticator_Response_Update struct {
	Status           *Authenticator_Response_Status `protobuf:"varint,1,opt,name=status,enum=MurmurRPC.Authenticator_Response_Status" json:"status,omitempty"`
	XXX_unrecognized []byte                         `json:"-"`
}

func (m *Authenticator_Response_Update) Reset()         { *m = Authenticator_Response_Update{} }
func (m *Authenticator_Response_Update) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Update) ProtoMessage()    {}

func (m *Authenticator_Response_Update) GetStatus() Authenticator_Response_Status {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Authenticator_Response_Fallthrough
}

type DatabaseUser struct {
	// The server on which the user is registered.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The unique user ID.
	Id *uint32 `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	// The user's name.
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// The user's email address.
	Email *string `protobuf:"bytes,4,opt,name=email" json:"email,omitempty"`
	// The user's comment.
	Comment *string `protobuf:"bytes,5,opt,name=comment" json:"comment,omitempty"`
	// The user's certificate hash.
	Hash *string `protobuf:"bytes,6,opt,name=hash" json:"hash,omitempty"`
	// The user's password (never sent; used only when updating).
	Password *string `protobuf:"bytes,7,opt,name=password" json:"password,omitempty"`
	// When the user was last on the server.
	LastActive *string `protobuf:"bytes,8,opt,name=last_active" json:"last_active,omitempty"`
	// The user's texture.
	Texture          []byte `protobuf:"bytes,9,opt,name=texture" json:"texture,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *DatabaseUser) Reset()         { *m = DatabaseUser{} }
func (m *DatabaseUser) String() string { return proto.CompactTextString(m) }
func (*DatabaseUser) ProtoMessage()    {}

func (m *DatabaseUser) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *DatabaseUser) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *DatabaseUser) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *DatabaseUser) GetEmail() string {
	if m != nil && m.Email != nil {
		return *m.Email
	}
	return ""
}

func (m *DatabaseUser) GetComment() string {
	if m != nil && m.Comment != nil {
		return *m.Comment
	}
	return ""
}

func (m *DatabaseUser) GetHash() string {
	if m != nil && m.Hash != nil {
		return *m.Hash
	}
	return ""
}

func (m *DatabaseUser) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *DatabaseUser) GetLastActive() string {
	if m != nil && m.LastActive != nil {
		return *m.LastActive
	}
	return ""
}

func (m *DatabaseUser) GetTexture() []byte {
	if m != nil {
		return m.Texture
	}
	return nil
}

type DatabaseUser_Query struct {
	// The server whose users will be queried.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// A string to filter the users by.
	Filter           *string `protobuf:"bytes,2,opt,name=filter" json:"filter,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DatabaseUser_Query) Reset()         { *m = DatabaseUser_Query{} }
func (m *DatabaseUser_Query) String() string { return proto.CompactTextString(m) }
func (*DatabaseUser_Query) ProtoMessage()    {}

func (m *DatabaseUser_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *DatabaseUser_Query) GetFilter() string {
	if m != nil && m.Filter != nil {
		return *m.Filter
	}
	return ""
}

type DatabaseUser_List struct {
	// The server on which the users are registered.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The users.
	Users            []*DatabaseUser `protobuf:"bytes,2,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *DatabaseUser_List) Reset()         { *m = DatabaseUser_List{} }
func (m *DatabaseUser_List) String() string { return proto.CompactTextString(m) }
func (*DatabaseUser_List) ProtoMessage()    {}

func (m *DatabaseUser_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *DatabaseUser_List) GetUsers() []*DatabaseUser {
	if m != nil {
		return m.Users
	}
	return nil
}

type DatabaseUser_Verify struct {
	// The server on which the user-password pair will be authenticated.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The user's name.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The user's password.
	Password         *string `protobuf:"bytes,3,opt,name=password" json:"password,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DatabaseUser_Verify) Reset()         { *m = DatabaseUser_Verify{} }
func (m *DatabaseUser_Verify) String() string { return proto.CompactTextString(m) }
func (*DatabaseUser_Verify) ProtoMessage()    {}

func (m *DatabaseUser_Verify) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *DatabaseUser_Verify) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *DatabaseUser_Verify) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

type RedirectWhisperGroup struct {
	// The server on which the whisper redirection will take place.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The user to whom the redirection will be applied.
	User *User `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	// The source group.
	Source *ACL_Group `protobuf:"bytes,3,opt,name=source" json:"source,omitempty"`
	// The target group.
	Target           *ACL_Group `protobuf:"bytes,4,opt,name=target" json:"target,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *RedirectWhisperGroup) Reset()         { *m = RedirectWhisperGroup{} }
func (m *RedirectWhisperGroup) String() string { return proto.CompactTextString(m) }
func (*RedirectWhisperGroup) ProtoMessage()    {}

func (m *RedirectWhisperGroup) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *RedirectWhisperGroup) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *RedirectWhisperGroup) GetSource() *ACL_Group {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *RedirectWhisperGroup) GetTarget() *ACL_Group {
	if m != nil {
		return m.Target
	}
	return nil
}

func init() {
	proto.RegisterEnum("MurmurRPC.Server_Event_Type", Server_Event_Type_name, Server_Event_Type_value)
	proto.RegisterEnum("MurmurRPC.Event_Type", Event_Type_name, Event_Type_value)
	proto.RegisterEnum("MurmurRPC.ContextAction_Context", ContextAction_Context_name, ContextAction_Context_value)
	proto.RegisterEnum("MurmurRPC.ACL_Permission", ACL_Permission_name, ACL_Permission_value)
	proto.RegisterEnum("MurmurRPC.Authenticator_Response_Status", Authenticator_Response_Status_name, Authenticator_Response_Status_value)
}

// Client API for ServerService service

type ServerServiceClient interface {
	// Create creates a new virtual server. The returned server object contains
	// the newly created server's ID.
	Create(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Server, error)
	// Query returns a list of servers that match the given query.
	Query(ctx context.Context, in *Server_Query, opts ...grpc.CallOption) (*Server_List, error)
	// Get returns information about the given server.
	Get(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Server, error)
	// Start starts the given stopped server.
	Start(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error)
	// Stop stops the given virtual server.
	Stop(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error)
	// Remove removes the given virtual server and its configuration.
	Remove(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error)
	// Events returns a stream of events that happen on the given server.
	Events(ctx context.Context, in *Server, opts ...grpc.CallOption) (ServerService_EventsClient, error)
}

type serverServiceClient struct {
	cc *grpc.ClientConn
}

func NewServerServiceClient(cc *grpc.ClientConn) ServerServiceClient {
	return &serverServiceClient{cc}
}

func (c *serverServiceClient) Create(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Server, error) {
	out := new(Server)
	err := grpc.Invoke(ctx, "/MurmurRPC.ServerService/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) Query(ctx context.Context, in *Server_Query, opts ...grpc.CallOption) (*Server_List, error) {
	out := new(Server_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.ServerService/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) Get(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Server, error) {
	out := new(Server)
	err := grpc.Invoke(ctx, "/MurmurRPC.ServerService/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) Start(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ServerService/Start", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) Stop(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ServerService/Stop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) Remove(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ServerService/Remove", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) Events(ctx context.Context, in *Server, opts ...grpc.CallOption) (ServerService_EventsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ServerService_serviceDesc.Streams[0], c.cc, "/MurmurRPC.ServerService/Events", opts...)
	if err != nil {
		return nil, err
	}
	x := &serverServiceEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ServerService_EventsClient interface {
	Recv() (*Server_Event, error)
	grpc.ClientStream
}

type serverServiceEventsClient struct {
	grpc.ClientStream
}

func (x *serverServiceEventsClient) Recv() (*Server_Event, error) {
	m := new(Server_Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ServerService service

type ServerServiceServer interface {
	// Create creates a new virtual server. The returned server object contains
	// the newly created server's ID.
	Create(context.Context, *Void) (*Server, error)
	// Query returns a list of servers that match the given query.
	Query(context.Context, *Server_Query) (*Server_List, error)
	// Get returns information about the given server.
	Get(context.Context, *Server) (*Server, error)
	// Start starts the given stopped server.
	Start(context.Context, *Server) (*Void, error)
	// Stop stops the given virtual server.
	Stop(context.Context, *Server) (*Void, error)
	// Remove removes the given virtual server and its configuration.
	Remove(context.Context, *Server) (*Void, error)
	// Events returns a stream of events that happen on the given server.
	Events(*Server, ServerService_EventsServer) error
}

func RegisterServerServiceServer(s *grpc.Server, srv ServerServiceServer) {
	s.RegisterService(&_ServerService_serviceDesc, srv)
}

func _ServerService_Create_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Void)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ServerServiceServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ServerService_Query_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Server_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ServerServiceServer).Query(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ServerService_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Server)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ServerServiceServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ServerService_Start_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Server)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ServerServiceServer).Start(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ServerService_Stop_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Server)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ServerServiceServer).Stop(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ServerService_Remove_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Server)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ServerServiceServer).Remove(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ServerService_Events_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Server)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ServerServiceServer).Events(m, &serverServiceEventsServer{stream})
}

type ServerService_EventsServer interface {
	Send(*Server_Event) error
	grpc.ServerStream
}

type serverServiceEventsServer struct {
	grpc.ServerStream
}

func (x *serverServiceEventsServer) Send(m *Server_Event) error {
	return x.ServerStream.SendMsg(m)
}

var _ServerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.ServerService",
	HandlerType: (*ServerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _ServerService_Create_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _ServerService_Query_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ServerService_Get_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _ServerService_Start_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _ServerService_Stop_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _ServerService_Remove_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Events",
			Handler:       _ServerService_Events_Handler,
			ServerStreams: true,
		},
	},
}

// Client API for MetaService service

type MetaServiceClient interface {
	// GetUptime returns murmur's uptime.
	GetUptime(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Uptime, error)
	// GetVersion returns murmur's version.
	GetVersion(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Version, error)
	// Events returns a stream of murmur events.
	Events(ctx context.Context, in *Void, opts ...grpc.CallOption) (MetaService_EventsClient, error)
}

type metaServiceClient struct {
	cc *grpc.ClientConn
}

func NewMetaServiceClient(cc *grpc.ClientConn) MetaServiceClient {
	return &metaServiceClient{cc}
}

func (c *metaServiceClient) GetUptime(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Uptime, error) {
	out := new(Uptime)
	err := grpc.Invoke(ctx, "/MurmurRPC.MetaService/GetUptime", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) GetVersion(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Version, error) {
	out := new(Version)
	err := grpc.Invoke(ctx, "/MurmurRPC.MetaService/GetVersion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) Events(ctx context.Context, in *Void, opts ...grpc.CallOption) (MetaService_EventsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MetaService_serviceDesc.Streams[0], c.cc, "/MurmurRPC.MetaService/Events", opts...)
	if err != nil {
		return nil, err
	}
	x := &metaServiceEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MetaService_EventsClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type metaServiceEventsClient struct {
	grpc.ClientStream
}

func (x *metaServiceEventsClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for MetaService service

type MetaServiceServer interface {
	// GetUptime returns murmur's uptime.
	GetUptime(context.Context, *Void) (*Uptime, error)
	// GetVersion returns murmur's version.
	GetVersion(context.Context, *Void) (*Version, error)
	// Events returns a stream of murmur events.
	Events(*Void, MetaService_EventsServer) error
}

func RegisterMetaServiceServer(s *grpc.Server, srv MetaServiceServer) {
	s.RegisterService(&_MetaService_serviceDesc, srv)
}

func _MetaService_GetUptime_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Void)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(MetaServiceServer).GetUptime(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _MetaService_GetVersion_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Void)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(MetaServiceServer).GetVersion(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _MetaService_Events_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Void)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MetaServiceServer).Events(m, &metaServiceEventsServer{stream})
}

type MetaService_EventsServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type metaServiceEventsServer struct {
	grpc.ServerStream
}

func (x *metaServiceEventsServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

var _MetaService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.MetaService",
	HandlerType: (*MetaServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUptime",
			Handler:    _MetaService_GetUptime_Handler,
		},
		{
			MethodName: "GetVersion",
			Handler:    _MetaService_GetVersion_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Events",
			Handler:       _MetaService_Events_Handler,
			ServerStreams: true,
		},
	},
}

// Client API for ContextActionService service

type ContextActionServiceClient interface {
	// Add adds a context action to the given user's client. The following
	// ContextAction fields must be set:
	//   context, action, text, and user.
	Add(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error)
	// Remove removes a context action from the given user's client. The
	// following ContextAction must be set:
	//   action
	// If no user is given, the context action is removed from all users.
	Remove(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error)
	// Events returns a stream of context action events that are triggered by
	// users.
	Events(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (ContextActionService_EventsClient, error)
}

type contextActionServiceClient struct {
	cc *grpc.ClientConn
}

func NewContextActionServiceClient(cc *grpc.ClientConn) ContextActionServiceClient {
	return &contextActionServiceClient{cc}
}

func (c *contextActionServiceClient) Add(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ContextActionService/Add", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contextActionServiceClient) Remove(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ContextActionService/Remove", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contextActionServiceClient) Events(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (ContextActionService_EventsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ContextActionService_serviceDesc.Streams[0], c.cc, "/MurmurRPC.ContextActionService/Events", opts...)
	if err != nil {
		return nil, err
	}
	x := &contextActionServiceEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ContextActionService_EventsClient interface {
	Recv() (*ContextAction, error)
	grpc.ClientStream
}

type contextActionServiceEventsClient struct {
	grpc.ClientStream
}

func (x *contextActionServiceEventsClient) Recv() (*ContextAction, error) {
	m := new(ContextAction)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ContextActionService service

type ContextActionServiceServer interface {
	// Add adds a context action to the given user's client. The following
	// ContextAction fields must be set:
	//   context, action, text, and user.
	Add(context.Context, *ContextAction) (*Void, error)
	// Remove removes a context action from the given user's client. The
	// following ContextAction must be set:
	//   action
	// If no user is given, the context action is removed from all users.
	Remove(context.Context, *ContextAction) (*Void, error)
	// Events returns a stream of context action events that are triggered by
	// users.
	Events(*ContextAction, ContextActionService_EventsServer) error
}

func RegisterContextActionServiceServer(s *grpc.Server, srv ContextActionServiceServer) {
	s.RegisterService(&_ContextActionService_serviceDesc, srv)
}

func _ContextActionService_Add_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ContextAction)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ContextActionServiceServer).Add(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ContextActionService_Remove_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ContextAction)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ContextActionServiceServer).Remove(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ContextActionService_Events_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ContextAction)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ContextActionServiceServer).Events(m, &contextActionServiceEventsServer{stream})
}

type ContextActionService_EventsServer interface {
	Send(*ContextAction) error
	grpc.ServerStream
}

type contextActionServiceEventsServer struct {
	grpc.ServerStream
}

func (x *contextActionServiceEventsServer) Send(m *ContextAction) error {
	return x.ServerStream.SendMsg(m)
}

var _ContextActionService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.ContextActionService",
	HandlerType: (*ContextActionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _ContextActionService_Add_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _ContextActionService_Remove_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Events",
			Handler:       _ContextActionService_Events_Handler,
			ServerStreams: true,
		},
	},
}

// Client API for TextMessageService service

type TextMessageServiceClient interface {
	// Send sends the given TextMessage to the server.
	//
	// If no users, channels, or trees are added to the TextMessage, the message
	// will be broadcast the entire server. Otherwise, the message will be
	// targeted to the specified users, channels, and trees.
	Send(ctx context.Context, in *TextMessage, opts ...grpc.CallOption) (*Void, error)
}

type textMessageServiceClient struct {
	cc *grpc.ClientConn
}

func NewTextMessageServiceClient(cc *grpc.ClientConn) TextMessageServiceClient {
	return &textMessageServiceClient{cc}
}

func (c *textMessageServiceClient) Send(ctx context.Context, in *TextMessage, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.TextMessageService/Send", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TextMessageService service

type TextMessageServiceServer interface {
	// Send sends the given TextMessage to the server.
	//
	// If no users, channels, or trees are added to the TextMessage, the message
	// will be broadcast the entire server. Otherwise, the message will be
	// targeted to the specified users, channels, and trees.
	Send(context.Context, *TextMessage) (*Void, error)
}

func RegisterTextMessageServiceServer(s *grpc.Server, srv TextMessageServiceServer) {
	s.RegisterService(&_TextMessageService_serviceDesc, srv)
}

func _TextMessageService_Send_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(TextMessage)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(TextMessageServiceServer).Send(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _TextMessageService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.TextMessageService",
	HandlerType: (*TextMessageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _TextMessageService_Send_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for LogService service

type LogServiceClient interface {
	// Query returns a list of log entries from the given server.
	//
	// To get the total number of log entries, omit min and/or max from the
	// query.
	Query(ctx context.Context, in *Log_Query, opts ...grpc.CallOption) (*Log_List, error)
}

type logServiceClient struct {
	cc *grpc.ClientConn
}

func NewLogServiceClient(cc *grpc.ClientConn) LogServiceClient {
	return &logServiceClient{cc}
}

func (c *logServiceClient) Query(ctx context.Context, in *Log_Query, opts ...grpc.CallOption) (*Log_List, error) {
	out := new(Log_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.LogService/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for LogService service

type LogServiceServer interface {
	// Query returns a list of log entries from the given server.
	//
	// To get the total number of log entries, omit min and/or max from the
	// query.
	Query(context.Context, *Log_Query) (*Log_List, error)
}

func RegisterLogServiceServer(s *grpc.Server, srv LogServiceServer) {
	s.RegisterService(&_LogService_serviceDesc, srv)
}

func _LogService_Query_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Log_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(LogServiceServer).Query(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _LogService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.LogService",
	HandlerType: (*LogServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Query",
			Handler:    _LogService_Query_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for ConfigService service

type ConfigServiceClient interface {
	// Get returns the explicitly set configuration for the given server.
	Get(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Config, error)
	// GetField returns the configuration value for the given key.
	GetField(ctx context.Context, in *Config_Field, opts ...grpc.CallOption) (*Config_Field, error)
	// SetField sets the configuration value to the given value.
	SetField(ctx context.Context, in *Config_Field, opts ...grpc.CallOption) (*Void, error)
	// GetDefaults returns the default server configuration.
	GetDefaults(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Config, error)
}

type configServiceClient struct {
	cc *grpc.ClientConn
}

func NewConfigServiceClient(cc *grpc.ClientConn) ConfigServiceClient {
	return &configServiceClient{cc}
}

func (c *configServiceClient) Get(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Config, error) {
	out := new(Config)
	err := grpc.Invoke(ctx, "/MurmurRPC.ConfigService/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) GetField(ctx context.Context, in *Config_Field, opts ...grpc.CallOption) (*Config_Field, error) {
	out := new(Config_Field)
	err := grpc.Invoke(ctx, "/MurmurRPC.ConfigService/GetField", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) SetField(ctx context.Context, in *Config_Field, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ConfigService/SetField", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) GetDefaults(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Config, error) {
	out := new(Config)
	err := grpc.Invoke(ctx, "/MurmurRPC.ConfigService/GetDefaults", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ConfigService service

type ConfigServiceServer interface {
	// Get returns the explicitly set configuration for the given server.
	Get(context.Context, *Server) (*Config, error)
	// GetField returns the configuration value for the given key.
	GetField(context.Context, *Config_Field) (*Config_Field, error)
	// SetField sets the configuration value to the given value.
	SetField(context.Context, *Config_Field) (*Void, error)
	// GetDefaults returns the default server configuration.
	GetDefaults(context.Context, *Void) (*Config, error)
}

func RegisterConfigServiceServer(s *grpc.Server, srv ConfigServiceServer) {
	s.RegisterService(&_ConfigService_serviceDesc, srv)
}

func _ConfigService_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Server)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ConfigServiceServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ConfigService_GetField_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Config_Field)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ConfigServiceServer).GetField(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ConfigService_SetField_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Config_Field)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ConfigServiceServer).SetField(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ConfigService_GetDefaults_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Void)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ConfigServiceServer).GetDefaults(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _ConfigService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.ConfigService",
	HandlerType: (*ConfigServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _ConfigService_Get_Handler,
		},
		{
			MethodName: "GetField",
			Handler:    _ConfigService_GetField_Handler,
		},
		{
			MethodName: "SetField",
			Handler:    _ConfigService_SetField_Handler,
		},
		{
			MethodName: "GetDefaults",
			Handler:    _ConfigService_GetDefaults_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for ChannelService service

type ChannelServiceClient interface {
	// Query returns a list of channels that match the given query.
	Query(ctx context.Context, in *Channel_Query, opts ...grpc.CallOption) (*Channel_List, error)
	// Get returns the channel with the given ID.
	Get(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error)
	// Add adds the channel to the given server. The parent and name of the
	// channel must be set.
	Add(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error)
	// Remove removes the given channel from the server.
	Remove(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Void, error)
	// Update updates the given channel's attributes. Only the fields that are
	// set will be updated.
	Update(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error)
}

type channelServiceClient struct {
	cc *grpc.ClientConn
}

func NewChannelServiceClient(cc *grpc.ClientConn) ChannelServiceClient {
	return &channelServiceClient{cc}
}

func (c *channelServiceClient) Query(ctx context.Context, in *Channel_Query, opts ...grpc.CallOption) (*Channel_List, error) {
	out := new(Channel_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.ChannelService/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelServiceClient) Get(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error) {
	out := new(Channel)
	err := grpc.Invoke(ctx, "/MurmurRPC.ChannelService/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelServiceClient) Add(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error) {
	out := new(Channel)
	err := grpc.Invoke(ctx, "/MurmurRPC.ChannelService/Add", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelServiceClient) Remove(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ChannelService/Remove", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelServiceClient) Update(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error) {
	out := new(Channel)
	err := grpc.Invoke(ctx, "/MurmurRPC.ChannelService/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ChannelService service

type ChannelServiceServer interface {
	// Query returns a list of channels that match the given query.
	Query(context.Context, *Channel_Query) (*Channel_List, error)
	// Get returns the channel with the given ID.
	Get(context.Context, *Channel) (*Channel, error)
	// Add adds the channel to the given server. The parent and name of the
	// channel must be set.
	Add(context.Context, *Channel) (*Channel, error)
	// Remove removes the given channel from the server.
	Remove(context.Context, *Channel) (*Void, error)
	// Update updates the given channel's attributes. Only the fields that are
	// set will be updated.
	Update(context.Context, *Channel) (*Channel, error)
}

func RegisterChannelServiceServer(s *grpc.Server, srv ChannelServiceServer) {
	s.RegisterService(&_ChannelService_serviceDesc, srv)
}

func _ChannelService_Query_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Channel_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ChannelServiceServer).Query(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ChannelService_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Channel)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ChannelServiceServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ChannelService_Add_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Channel)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ChannelServiceServer).Add(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ChannelService_Remove_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Channel)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ChannelServiceServer).Remove(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ChannelService_Update_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Channel)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ChannelServiceServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _ChannelService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.ChannelService",
	HandlerType: (*ChannelServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Query",
			Handler:    _ChannelService_Query_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ChannelService_Get_Handler,
		},
		{
			MethodName: "Add",
			Handler:    _ChannelService_Add_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _ChannelService_Remove_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ChannelService_Update_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for UserService service

type UserServiceClient interface {
	// Query returns a list of connected users who match the given query.
	Query(ctx context.Context, in *User_Query, opts ...grpc.CallOption) (*User_List, error)
	// Get returns information on the connected user, given by the user's session
	// or name.
	Get(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	// Update changes the given user's state. Only the following fields can be
	// changed:
	//   name, mute, deaf, suppress, priority_speaker, channel, comment.
	Update(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	// Kick kicks the user from the server.
	Kick(ctx context.Context, in *User_Kick, opts ...grpc.CallOption) (*Void, error)
}

type userServiceClient struct {
	cc *grpc.ClientConn
}

func NewUserServiceClient(cc *grpc.ClientConn) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) Query(ctx context.Context, in *User_Query, opts ...grpc.CallOption) (*User_List, error) {
	out := new(User_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.UserService/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Get(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/MurmurRPC.UserService/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Update(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/MurmurRPC.UserService/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Kick(ctx context.Context, in *User_Kick, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.UserService/Kick", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for UserService service

type UserServiceServer interface {
	// Query returns a list of connected users who match the given query.
	Query(context.Context, *User_Query) (*User_List, error)
	// Get returns information on the connected user, given by the user's session
	// or name.
	Get(context.Context, *User) (*User, error)
	// Update changes the given user's state. Only the following fields can be
	// changed:
	//   name, mute, deaf, suppress, priority_speaker, channel, comment.
	Update(context.Context, *User) (*User, error)
	// Kick kicks the user from the server.
	Kick(context.Context, *User_Kick) (*Void, error)
}

func RegisterUserServiceServer(s *grpc.Server, srv UserServiceServer) {
	s.RegisterService(&_UserService_serviceDesc, srv)
}

func _UserService_Query_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(User_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(UserServiceServer).Query(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _UserService_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(User)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(UserServiceServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _UserService_Update_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(User)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(UserServiceServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _UserService_Kick_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(User_Kick)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(UserServiceServer).Kick(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _UserService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Query",
			Handler:    _UserService_Query_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _UserService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _UserService_Update_Handler,
		},
		{
			MethodName: "Kick",
			Handler:    _UserService_Kick_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for TreeService service

type TreeServiceClient interface {
	// Query returns a representation of the given server's channel/user tree.
	Query(ctx context.Context, in *Tree_Query, opts ...grpc.CallOption) (*Tree, error)
}

type treeServiceClient struct {
	cc *grpc.ClientConn
}

func NewTreeServiceClient(cc *grpc.ClientConn) TreeServiceClient {
	return &treeServiceClient{cc}
}

func (c *treeServiceClient) Query(ctx context.Context, in *Tree_Query, opts ...grpc.CallOption) (*Tree, error) {
	out := new(Tree)
	err := grpc.Invoke(ctx, "/MurmurRPC.TreeService/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TreeService service

type TreeServiceServer interface {
	// Query returns a representation of the given server's channel/user tree.
	Query(context.Context, *Tree_Query) (*Tree, error)
}

func RegisterTreeServiceServer(s *grpc.Server, srv TreeServiceServer) {
	s.RegisterService(&_TreeService_serviceDesc, srv)
}

func _TreeService_Query_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Tree_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(TreeServiceServer).Query(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _TreeService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.TreeService",
	HandlerType: (*TreeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Query",
			Handler:    _TreeService_Query_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for BanService service

type BanServiceClient interface {
	// Get returns a list of bans for the given server.
	Get(ctx context.Context, in *Ban_Query, opts ...grpc.CallOption) (*Ban_List, error)
	// Set replaces the server's ban list with the given list.
	Set(ctx context.Context, in *Ban_List, opts ...grpc.CallOption) (*Void, error)
}

type banServiceClient struct {
	cc *grpc.ClientConn
}

func NewBanServiceClient(cc *grpc.ClientConn) BanServiceClient {
	return &banServiceClient{cc}
}

func (c *banServiceClient) Get(ctx context.Context, in *Ban_Query, opts ...grpc.CallOption) (*Ban_List, error) {
	out := new(Ban_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.BanService/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *banServiceClient) Set(ctx context.Context, in *Ban_List, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.BanService/Set", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for BanService service

type BanServiceServer interface {
	// Get returns a list of bans for the given server.
	Get(context.Context, *Ban_Query) (*Ban_List, error)
	// Set replaces the server's ban list with the given list.
	Set(context.Context, *Ban_List) (*Void, error)
}

func RegisterBanServiceServer(s *grpc.Server, srv BanServiceServer) {
	s.RegisterService(&_BanService_serviceDesc, srv)
}

func _BanService_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Ban_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(BanServiceServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _BanService_Set_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Ban_List)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(BanServiceServer).Set(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _BanService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.BanService",
	HandlerType: (*BanServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _BanService_Get_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _BanService_Set_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for ACLService service

type ACLServiceClient interface {
	// Get returns the ACL for the given channel.
	Get(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*ACL_List, error)
	// Set overrides the ACL of the given channel to what is provided.
	Set(ctx context.Context, in *ACL_List, opts ...grpc.CallOption) (*Void, error)
	// GetEffectivePermissions returns the effective permissions for the given
	// user in the given channel.
	GetEffectivePermissions(ctx context.Context, in *ACL_Query, opts ...grpc.CallOption) (*ACL, error)
	// AddTemporaryGroup adds a user to a temporary group.
	AddTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error)
	// RemoveTemporaryGroup removes a user from a temporary group.
	RemoveTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error)
}

type aCLServiceClient struct {
	cc *grpc.ClientConn
}

func NewACLServiceClient(cc *grpc.ClientConn) ACLServiceClient {
	return &aCLServiceClient{cc}
}

func (c *aCLServiceClient) Get(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*ACL_List, error) {
	out := new(ACL_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.ACLService/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aCLServiceClient) Set(ctx context.Context, in *ACL_List, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ACLService/Set", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aCLServiceClient) GetEffectivePermissions(ctx context.Context, in *ACL_Query, opts ...grpc.CallOption) (*ACL, error) {
	out := new(ACL)
	err := grpc.Invoke(ctx, "/MurmurRPC.ACLService/GetEffectivePermissions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aCLServiceClient) AddTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ACLService/AddTemporaryGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aCLServiceClient) RemoveTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.ACLService/RemoveTemporaryGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ACLService service

type ACLServiceServer interface {
	// Get returns the ACL for the given channel.
	Get(context.Context, *Channel) (*ACL_List, error)
	// Set overrides the ACL of the given channel to what is provided.
	Set(context.Context, *ACL_List) (*Void, error)
	// GetEffectivePermissions returns the effective permissions for the given
	// user in the given channel.
	GetEffectivePermissions(context.Context, *ACL_Query) (*ACL, error)
	// AddTemporaryGroup adds a user to a temporary group.
	AddTemporaryGroup(context.Context, *ACL_TemporaryGroup) (*Void, error)
	// RemoveTemporaryGroup removes a user from a temporary group.
	RemoveTemporaryGroup(context.Context, *ACL_TemporaryGroup) (*Void, error)
}

func RegisterACLServiceServer(s *grpc.Server, srv ACLServiceServer) {
	s.RegisterService(&_ACLService_serviceDesc, srv)
}

func _ACLService_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Channel)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ACLServiceServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ACLService_Set_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ACL_List)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ACLServiceServer).Set(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ACLService_GetEffectivePermissions_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ACL_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ACLServiceServer).GetEffectivePermissions(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ACLService_AddTemporaryGroup_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ACL_TemporaryGroup)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ACLServiceServer).AddTemporaryGroup(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ACLService_RemoveTemporaryGroup_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ACL_TemporaryGroup)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ACLServiceServer).RemoveTemporaryGroup(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _ACLService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.ACLService",
	HandlerType: (*ACLServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _ACLService_Get_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _ACLService_Set_Handler,
		},
		{
			MethodName: "GetEffectivePermissions",
			Handler:    _ACLService_GetEffectivePermissions_Handler,
		},
		{
			MethodName: "AddTemporaryGroup",
			Handler:    _ACLService_AddTemporaryGroup_Handler,
		},
		{
			MethodName: "RemoveTemporaryGroup",
			Handler:    _ACLService_RemoveTemporaryGroup_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for AuthenticatorService service

type AuthenticatorServiceClient interface {
	// Stream opens an authentication stream to the server.
	//
	// There can only be one RPC client with an open Stream. If a new
	// authenticator connects, the open connected will be closed.
	Stream(ctx context.Context, opts ...grpc.CallOption) (AuthenticatorService_StreamClient, error)
}

type authenticatorServiceClient struct {
	cc *grpc.ClientConn
}

func NewAuthenticatorServiceClient(cc *grpc.ClientConn) AuthenticatorServiceClient {
	return &authenticatorServiceClient{cc}
}

func (c *authenticatorServiceClient) Stream(ctx context.Context, opts ...grpc.CallOption) (AuthenticatorService_StreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AuthenticatorService_serviceDesc.Streams[0], c.cc, "/MurmurRPC.AuthenticatorService/Stream", opts...)
	if err != nil {
		return nil, err
	}
	x := &authenticatorServiceStreamClient{stream}
	return x, nil
}

type AuthenticatorService_StreamClient interface {
	Send(*Authenticator_Response) error
	Recv() (*Authenticator_Request, error)
	grpc.ClientStream
}

type authenticatorServiceStreamClient struct {
	grpc.ClientStream
}

func (x *authenticatorServiceStreamClient) Send(m *Authenticator_Response) error {
	return x.ClientStream.SendMsg(m)
}

func (x *authenticatorServiceStreamClient) Recv() (*Authenticator_Request, error) {
	m := new(Authenticator_Request)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AuthenticatorService service

type AuthenticatorServiceServer interface {
	// Stream opens an authentication stream to the server.
	//
	// There can only be one RPC client with an open Stream. If a new
	// authenticator connects, the open connected will be closed.
	Stream(AuthenticatorService_StreamServer) error
}

func RegisterAuthenticatorServiceServer(s *grpc.Server, srv AuthenticatorServiceServer) {
	s.RegisterService(&_AuthenticatorService_serviceDesc, srv)
}

func _AuthenticatorService_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AuthenticatorServiceServer).Stream(&authenticatorServiceStreamServer{stream})
}

type AuthenticatorService_StreamServer interface {
	Send(*Authenticator_Request) error
	Recv() (*Authenticator_Response, error)
	grpc.ServerStream
}

type authenticatorServiceStreamServer struct {
	grpc.ServerStream
}

func (x *authenticatorServiceStreamServer) Send(m *Authenticator_Request) error {
	return x.ServerStream.SendMsg(m)
}

func (x *authenticatorServiceStreamServer) Recv() (*Authenticator_Response, error) {
	m := new(Authenticator_Response)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _AuthenticatorService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.AuthenticatorService",
	HandlerType: (*AuthenticatorServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Stream",
			Handler:       _AuthenticatorService_Stream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
}

// Client API for DatabaseService service

type DatabaseServiceClient interface {
	// Query returns a list of registered users who match given query.
	Query(ctx context.Context, in *DatabaseUser_Query, opts ...grpc.CallOption) (*DatabaseUser_List, error)
	// Get returns the database user with the given id.
	Get(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error)
	// Update updates the given database user.
	Update(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error)
	// Register registers a user with the given information on the server. The
	// returned DatabaseUser will contain the newly registered user's ID.
	Register(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error)
	// Deregister deregisters the given user.
	Deregister(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error)
	// Verify verifies the that the given user-password pair is correct.
	Verify(ctx context.Context, in *DatabaseUser_Verify, opts ...grpc.CallOption) (*DatabaseUser, error)
}

type databaseServiceClient struct {
	cc *grpc.ClientConn
}

func NewDatabaseServiceClient(cc *grpc.ClientConn) DatabaseServiceClient {
	return &databaseServiceClient{cc}
}

func (c *databaseServiceClient) Query(ctx context.Context, in *DatabaseUser_Query, opts ...grpc.CallOption) (*DatabaseUser_List, error) {
	out := new(DatabaseUser_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.DatabaseService/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseServiceClient) Get(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error) {
	out := new(DatabaseUser)
	err := grpc.Invoke(ctx, "/MurmurRPC.DatabaseService/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseServiceClient) Update(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.DatabaseService/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseServiceClient) Register(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error) {
	out := new(DatabaseUser)
	err := grpc.Invoke(ctx, "/MurmurRPC.DatabaseService/Register", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseServiceClient) Deregister(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.DatabaseService/Deregister", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseServiceClient) Verify(ctx context.Context, in *DatabaseUser_Verify, opts ...grpc.CallOption) (*DatabaseUser, error) {
	out := new(DatabaseUser)
	err := grpc.Invoke(ctx, "/MurmurRPC.DatabaseService/Verify", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DatabaseService service

type DatabaseServiceServer interface {
	// Query returns a list of registered users who match given query.
	Query(context.Context, *DatabaseUser_Query) (*DatabaseUser_List, error)
	// Get returns the database user with the given id.
	Get(context.Context, *DatabaseUser) (*DatabaseUser, error)
	// Update updates the given database user.
	Update(context.Context, *DatabaseUser) (*Void, error)
	// Register registers a user with the given information on the server. The
	// returned DatabaseUser will contain the newly registered user's ID.
	Register(context.Context, *DatabaseUser) (*DatabaseUser, error)
	// Deregister deregisters the given user.
	Deregister(context.Context, *DatabaseUser) (*Void, error)
	// Verify verifies the that the given user-password pair is correct.
	Verify(context.Context, *DatabaseUser_Verify) (*DatabaseUser, error)
}

func RegisterDatabaseServiceServer(s *grpc.Server, srv DatabaseServiceServer) {
	s.RegisterService(&_DatabaseService_serviceDesc, srv)
}

func _DatabaseService_Query_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DatabaseUser_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DatabaseServiceServer).Query(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DatabaseService_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DatabaseUser)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DatabaseServiceServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DatabaseService_Update_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DatabaseUser)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DatabaseServiceServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DatabaseService_Register_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DatabaseUser)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DatabaseServiceServer).Register(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DatabaseService_Deregister_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DatabaseUser)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DatabaseServiceServer).Deregister(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DatabaseService_Verify_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DatabaseUser_Verify)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DatabaseServiceServer).Verify(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _DatabaseService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.DatabaseService",
	HandlerType: (*DatabaseServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Query",
			Handler:    _DatabaseService_Query_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _DatabaseService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _DatabaseService_Update_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _DatabaseService_Register_Handler,
		},
		{
			MethodName: "Deregister",
			Handler:    _DatabaseService_Deregister_Handler,
		},
		{
			MethodName: "Verify",
			Handler:    _DatabaseService_Verify_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for AudioService service

type AudioServiceClient interface {
	// AddRedirectWhisperGroup add a whisper targets redirection for the given
	// user. Whenever a user whispers to group "source", the whisper will be
	// redirected to group "target".
	AddRedirectWhisperGroup(ctx context.Context, in *RedirectWhisperGroup, opts ...grpc.CallOption) (*Void, error)
	// RemoveRedirectWhisperGroup removes a whisper target redirection for
	// the the given user.
	RemoveRedirectWhisperGroup(ctx context.Context, in *RedirectWhisperGroup, opts ...grpc.CallOption) (*Void, error)
}

type audioServiceClient struct {
	cc *grpc.ClientConn
}

func NewAudioServiceClient(cc *grpc.ClientConn) AudioServiceClient {
	return &audioServiceClient{cc}
}

func (c *audioServiceClient) AddRedirectWhisperGroup(ctx context.Context, in *RedirectWhisperGroup, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.AudioService/AddRedirectWhisperGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioServiceClient) RemoveRedirectWhisperGroup(ctx context.Context, in *RedirectWhisperGroup, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.AudioService/RemoveRedirectWhisperGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AudioService service

type AudioServiceServer interface {
	// AddRedirectWhisperGroup add a whisper targets redirection for the given
	// user. Whenever a user whispers to group "source", the whisper will be
	// redirected to group "target".
	AddRedirectWhisperGroup(context.Context, *RedirectWhisperGroup) (*Void, error)
	// RemoveRedirectWhisperGroup removes a whisper target redirection for
	// the the given user.
	RemoveRedirectWhisperGroup(context.Context, *RedirectWhisperGroup) (*Void, error)
}

func RegisterAudioServiceServer(s *grpc.Server, srv AudioServiceServer) {
	s.RegisterService(&_AudioService_serviceDesc, srv)
}

func _AudioService_AddRedirectWhisperGroup_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RedirectWhisperGroup)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(AudioServiceServer).AddRedirectWhisperGroup(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AudioService_RemoveRedirectWhisperGroup_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RedirectWhisperGroup)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(AudioServiceServer).RemoveRedirectWhisperGroup(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _AudioService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.AudioService",
	HandlerType: (*AudioServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddRedirectWhisperGroup",
			Handler:    _AudioService_AddRedirectWhisperGroup_Handler,
		},
		{
			MethodName: "RemoveRedirectWhisperGroup",
			Handler:    _AudioService_RemoveRedirectWhisperGroup_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
