// Code generated by protoc-gen-go.
// source: MurmurRPC.proto
// DO NOT EDIT!

/*
Package MurmurRPC is a generated protocol buffer package.

It is generated from these files:
	MurmurRPC.proto

It has these top-level messages:
	Void
	Version
	Uptime
	Server
	Event
	ContextAction
	TextMessage
	Log
	Config
	Channel
	User
	Tree
	Ban
	ACL
	Authenticator
	DatabaseUser
	RedirectWhisperGroup
*/
package MurmurRPC

import proto "github.com/golang/protobuf/proto"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type Server_Event_Type int32

const (
	Server_Event_UserConnected       Server_Event_Type = 0
	Server_Event_UserDisconnected    Server_Event_Type = 1
	Server_Event_UserStateChanged    Server_Event_Type = 2
	Server_Event_UserTextMessage     Server_Event_Type = 3
	Server_Event_ChannelCreated      Server_Event_Type = 4
	Server_Event_ChannelRemoved      Server_Event_Type = 5
	Server_Event_ChannelStateChanged Server_Event_Type = 6
)

var Server_Event_Type_name = map[int32]string{
	0: "UserConnected",
	1: "UserDisconnected",
	2: "UserStateChanged",
	3: "UserTextMessage",
	4: "ChannelCreated",
	5: "ChannelRemoved",
	6: "ChannelStateChanged",
}
var Server_Event_Type_value = map[string]int32{
	"UserConnected":       0,
	"UserDisconnected":    1,
	"UserStateChanged":    2,
	"UserTextMessage":     3,
	"ChannelCreated":      4,
	"ChannelRemoved":      5,
	"ChannelStateChanged": 6,
}

func (x Server_Event_Type) Enum() *Server_Event_Type {
	p := new(Server_Event_Type)
	*p = x
	return p
}
func (x Server_Event_Type) String() string {
	return proto.EnumName(Server_Event_Type_name, int32(x))
}
func (x *Server_Event_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Server_Event_Type_value, data, "Server_Event_Type")
	if err != nil {
		return err
	}
	*x = Server_Event_Type(value)
	return nil
}

type Event_Type int32

const (
	Event_ServerStopped Event_Type = 0
	Event_ServerStarted Event_Type = 1
)

var Event_Type_name = map[int32]string{
	0: "ServerStopped",
	1: "ServerStarted",
}
var Event_Type_value = map[string]int32{
	"ServerStopped": 0,
	"ServerStarted": 1,
}

func (x Event_Type) Enum() *Event_Type {
	p := new(Event_Type)
	*p = x
	return p
}
func (x Event_Type) String() string {
	return proto.EnumName(Event_Type_name, int32(x))
}
func (x *Event_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Event_Type_value, data, "Event_Type")
	if err != nil {
		return err
	}
	*x = Event_Type(value)
	return nil
}

type ContextAction_Context int32

const (
	ContextAction_Server  ContextAction_Context = 1
	ContextAction_Channel ContextAction_Context = 2
	ContextAction_User    ContextAction_Context = 4
)

var ContextAction_Context_name = map[int32]string{
	1: "Server",
	2: "Channel",
	4: "User",
}
var ContextAction_Context_value = map[string]int32{
	"Server":  1,
	"Channel": 2,
	"User":    4,
}

func (x ContextAction_Context) Enum() *ContextAction_Context {
	p := new(ContextAction_Context)
	*p = x
	return p
}
func (x ContextAction_Context) String() string {
	return proto.EnumName(ContextAction_Context_name, int32(x))
}
func (x *ContextAction_Context) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ContextAction_Context_value, data, "ContextAction_Context")
	if err != nil {
		return err
	}
	*x = ContextAction_Context(value)
	return nil
}

type TextMessage_Filter_Action int32

const (
	// Accept the message.
	TextMessage_Filter_Accept TextMessage_Filter_Action = 0
	// Reject the message with a permission error.
	TextMessage_Filter_Reject TextMessage_Filter_Action = 1
	// Silently drop the message.
	TextMessage_Filter_Drop TextMessage_Filter_Action = 2
)

var TextMessage_Filter_Action_name = map[int32]string{
	0: "Accept",
	1: "Reject",
	2: "Drop",
}
var TextMessage_Filter_Action_value = map[string]int32{
	"Accept": 0,
	"Reject": 1,
	"Drop":   2,
}

func (x TextMessage_Filter_Action) Enum() *TextMessage_Filter_Action {
	p := new(TextMessage_Filter_Action)
	*p = x
	return p
}
func (x TextMessage_Filter_Action) String() string {
	return proto.EnumName(TextMessage_Filter_Action_name, int32(x))
}
func (x *TextMessage_Filter_Action) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TextMessage_Filter_Action_value, data, "TextMessage_Filter_Action")
	if err != nil {
		return err
	}
	*x = TextMessage_Filter_Action(value)
	return nil
}

type ACL_Permission int32

const (
	ACL_None                 ACL_Permission = 0
	ACL_Write                ACL_Permission = 1
	ACL_Traverse             ACL_Permission = 2
	ACL_Enter                ACL_Permission = 4
	ACL_Speak                ACL_Permission = 8
	ACL_Whisper              ACL_Permission = 256
	ACL_MuteDeafen           ACL_Permission = 16
	ACL_Move                 ACL_Permission = 32
	ACL_MakeChannel          ACL_Permission = 64
	ACL_MakeTemporaryChannel ACL_Permission = 1024
	ACL_LinkChannel          ACL_Permission = 128
	ACL_TextMessage          ACL_Permission = 512
	ACL_Kick                 ACL_Permission = 65536
	ACL_Ban                  ACL_Permission = 131072
	ACL_Register             ACL_Permission = 262144
	ACL_RegisterSelf         ACL_Permission = 524288
)

var ACL_Permission_name = map[int32]string{
	0:      "None",
	1:      "Write",
	2:      "Traverse",
	4:      "Enter",
	8:      "Speak",
	256:    "Whisper",
	16:     "MuteDeafen",
	32:     "Move",
	64:     "MakeChannel",
	1024:   "MakeTemporaryChannel",
	128:    "LinkChannel",
	512:    "TextMessage",
	65536:  "Kick",
	131072: "Ban",
	262144: "Register",
	524288: "RegisterSelf",
}
var ACL_Permission_value = map[string]int32{
	"None":                 0,
	"Write":                1,
	"Traverse":             2,
	"Enter":                4,
	"Speak":                8,
	"Whisper":              256,
	"MuteDeafen":           16,
	"Move":                 32,
	"MakeChannel":          64,
	"MakeTemporaryChannel": 1024,
	"LinkChannel":          128,
	"TextMessage":          512,
	"Kick":                 65536,
	"Ban":                  131072,
	"Register":             262144,
	"RegisterSelf":         524288,
}

func (x ACL_Permission) Enum() *ACL_Permission {
	p := new(ACL_Permission)
	*p = x
	return p
}
func (x ACL_Permission) String() string {
	return proto.EnumName(ACL_Permission_name, int32(x))
}
func (x *ACL_Permission) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ACL_Permission_value, data, "ACL_Permission")
	if err != nil {
		return err
	}
	*x = ACL_Permission(value)
	return nil
}

type Authenticator_Response_Status int32

const (
	// The request should fallthrough to murmur's default action.
	Authenticator_Response_Fallthrough Authenticator_Response_Status = 0
	// The request was successful.
	Authenticator_Response_Success Authenticator_Response_Status = 1
	// The request failed; there was some error.
	Authenticator_Response_Failure Authenticator_Response_Status = 2
	// A temporary failure prevented the request from succeeding (e.g. a
	// database was unavailable).
	Authenticator_Response_TemporaryFailure Authenticator_Response_Status = 3
)

var Authenticator_Response_Status_name = map[int32]string{
	0: "Fallthrough",
	1: "Success",
	2: "Failure",
	3: "TemporaryFailure",
}
var Authenticator_Response_Status_value = map[string]int32{
	"Fallthrough":      0,
	"Success":          1,
	"Failure":          2,
	"TemporaryFailure": 3,
}

func (x Authenticator_Response_Status) Enum() *Authenticator_Response_Status {
	p := new(Authenticator_Response_Status)
	*p = x
	return p
}
func (x Authenticator_Response_Status) String() string {
	return proto.EnumName(Authenticator_Response_Status_name, int32(x))
}
func (x *Authenticator_Response_Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Authenticator_Response_Status_value, data, "Authenticator_Response_Status")
	if err != nil {
		return err
	}
	*x = Authenticator_Response_Status(value)
	return nil
}

type Void struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Void) Reset()         { *m = Void{} }
func (m *Void) String() string { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()    {}

type Version struct {
	// 2-byte Major, 1-byte Minor and 1-byte Patch version number.
	Version *uint32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	// Client release name.
	Release *string `protobuf:"bytes,2,opt,name=release" json:"release,omitempty"`
	// Client OS name.
	Os *string `protobuf:"bytes,3,opt,name=os" json:"os,omitempty"`
	// Client OS version.
	OsVersion        *string `protobuf:"bytes,4,opt,name=os_version" json:"os_version,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Version) Reset()         { *m = Version{} }
func (m *Version) String() string { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()    {}

func (m *Version) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *Version) GetRelease() string {
	if m != nil && m.Release != nil {
		return *m.Release
	}
	return ""
}

func (m *Version) GetOs() string {
	if m != nil && m.Os != nil {
		return *m.Os
	}
	return ""
}

func (m *Version) GetOsVersion() string {
	if m != nil && m.OsVersion != nil {
		return *m.OsVersion
	}
	return ""
}

type Uptime struct {
	// The number of seconds from the starting time.
	Secs             *uint64 `protobuf:"varint,1,opt,name=secs" json:"secs,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Uptime) Reset()         { *m = Uptime{} }
func (m *Uptime) String() string { return proto.CompactTextString(m) }
func (*Uptime) ProtoMessage()    {}

func (m *Uptime) GetSecs() uint64 {
	if m != nil && m.Secs != nil {
		return *m.Secs
	}
	return 0
}

type Server struct {
	// The unique server ID.
	Id *uint32 `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
	// Is the server currently running?
	Running *bool `protobuf:"varint,2,opt,name=running" json:"running,omitempty"`
	// The update of the server.
	Uptime           *Uptime `protobuf:"bytes,3,opt,name=uptime" json:"uptime,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Server) Reset()         { *m = Server{} }
func (m *Server) String() string { return proto.CompactTextString(m) }
func (*Server) ProtoMessage()    {}

func (m *Server) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Server) GetRunning() bool {
	if m != nil && m.Running != nil {
		return *m.Running
	}
	return false
}

func (m *Server) GetUptime() *Uptime {
	if m != nil {
		return m.Uptime
	}
	return nil
}

type Server_Event struct {
	// The server on which the event happened.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The type of event that happened.
	Type *Server_Event_Type `protobuf:"varint,2,opt,name=type,enum=MurmurRPC.Server_Event_Type" json:"type,omitempty"`
	// The user tied to the event (if applicable).
	User *User `protobuf:"bytes,3,opt,name=user" json:"user,omitempty"`
	// The text message tied to the event (if applicable).
	Message *TextMessage `protobuf:"bytes,4,opt,name=message" json:"message,omitempty"`
	// The channel tied to the event (if applicable).
	Channel          *Channel `protobuf:"bytes,5,opt,name=channel" json:"channel,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Server_Event) Reset()         { *m = Server_Event{} }
func (m *Server_Event) String() string { return proto.CompactTextString(m) }
func (*Server_Event) ProtoMessage()    {}

func (m *Server_Event) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Server_Event) GetType() Server_Event_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Server_Event_UserConnected
}

func (m *Server_Event) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Server_Event) GetMessage() *TextMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Server_Event) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

type Server_Query struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Server_Query) Reset()         { *m = Server_Query{} }
func (m *Server_Query) String() string { return proto.CompactTextString(m) }
func (*Server_Query) ProtoMessage()    {}

type Server_List struct {
	// The servers.
	Servers          []*Server `protobuf:"bytes,1,rep,name=servers" json:"servers,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Server_List) Reset()         { *m = Server_List{} }
func (m *Server_List) String() string { return proto.CompactTextString(m) }
func (*Server_List) ProtoMessage()    {}

func (m *Server_List) GetServers() []*Server {
	if m != nil {
		return m.Servers
	}
	return nil
}

type Event struct {
	// The server for which the event happened.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The type of event that happened.
	Type             *Event_Type `protobuf:"varint,2,opt,name=type,enum=MurmurRPC.Event_Type" json:"type,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}

func (m *Event) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Event) GetType() Event_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Event_ServerStopped
}

type ContextAction struct {
	// The server on which the action is.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The context in which the action is.
	Context *uint32 `protobuf:"varint,2,opt,name=context" json:"context,omitempty"`
	// The action name.
	Action *string `protobuf:"bytes,3,opt,name=action" json:"action,omitempty"`
	// The user-visible descriptive name of the action.
	Text *string `protobuf:"bytes,4,opt,name=text" json:"text,omitempty"`
	// The user that triggered the ContextAction.
	Actor *User `protobuf:"bytes,5,opt,name=actor" json:"actor,omitempty"`
	// The user on which the ContextAction was triggered.
	User *User `protobuf:"bytes,6,opt,name=user" json:"user,omitempty"`
	// The channel on which the ContextAction was triggered.
	Channel          *Channel `protobuf:"bytes,7,opt,name=channel" json:"channel,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ContextAction) Reset()         { *m = ContextAction{} }
func (m *ContextAction) String() string { return proto.CompactTextString(m) }
func (*ContextAction) ProtoMessage()    {}

func (m *ContextAction) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *ContextAction) GetContext() uint32 {
	if m != nil && m.Context != nil {
		return *m.Context
	}
	return 0
}

func (m *ContextAction) GetAction() string {
	if m != nil && m.Action != nil {
		return *m.Action
	}
	return ""
}

func (m *ContextAction) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

func (m *ContextAction) GetActor() *User {
	if m != nil {
		return m.Actor
	}
	return nil
}

func (m *ContextAction) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ContextAction) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

type TextMessage struct {
	// The server on which the TextMessage originates.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The user who sent the message.
	Actor *User `protobuf:"bytes,2,opt,name=actor" json:"actor,omitempty"`
	// The users to whom the message is sent.
	Users []*User `protobuf:"bytes,3,rep,name=users" json:"users,omitempty"`
	// The channels to which the message is sent.
	Channels []*Channel `protobuf:"bytes,4,rep,name=channels" json:"channels,omitempty"`
	// The channels to which the message is sent, including the channels'
	// ancestors.
	Trees []*Channel `protobuf:"bytes,5,rep,name=trees" json:"trees,omitempty"`
	// The message body that is sent.
	Text             *string `protobuf:"bytes,6,opt,name=text" json:"text,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TextMessage) Reset()         { *m = TextMessage{} }
func (m *TextMessage) String() string { return proto.CompactTextString(m) }
func (*TextMessage) ProtoMessage()    {}

func (m *TextMessage) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *TextMessage) GetActor() *User {
	if m != nil {
		return m.Actor
	}
	return nil
}

func (m *TextMessage) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *TextMessage) GetChannels() []*Channel {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *TextMessage) GetTrees() []*Channel {
	if m != nil {
		return m.Trees
	}
	return nil
}

func (m *TextMessage) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

type TextMessage_Filter struct {
	// The server on which the message originated.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The action to perform for the message.
	Action *TextMessage_Filter_Action `protobuf:"varint,2,opt,name=action,enum=MurmurRPC.TextMessage_Filter_Action" json:"action,omitempty"`
	// The text message.
	Message          *TextMessage `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *TextMessage_Filter) Reset()         { *m = TextMessage_Filter{} }
func (m *TextMessage_Filter) String() string { return proto.CompactTextString(m) }
func (*TextMessage_Filter) ProtoMessage()    {}

func (m *TextMessage_Filter) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *TextMessage_Filter) GetAction() TextMessage_Filter_Action {
	if m != nil && m.Action != nil {
		return *m.Action
	}
	return TextMessage_Filter_Accept
}

func (m *TextMessage_Filter) GetMessage() *TextMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

type Log struct {
	// The server on which the log message was generated.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The unix timestamp of when the message was generated.
	Timestamp *int64 `protobuf:"varint,2,opt,name=timestamp" json:"timestamp,omitempty"`
	// The log message.
	Text             *string `protobuf:"bytes,3,opt,name=text" json:"text,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Log) Reset()         { *m = Log{} }
func (m *Log) String() string { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()    {}

func (m *Log) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Log) GetTimestamp() int64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *Log) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

type Log_Query struct {
	// The server whose logs will be queried.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The minimum log index to receive.
	Min *uint32 `protobuf:"varint,2,opt,name=min" json:"min,omitempty"`
	// The maximum log index to receive.
	Max              *uint32 `protobuf:"varint,3,opt,name=max" json:"max,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Log_Query) Reset()         { *m = Log_Query{} }
func (m *Log_Query) String() string { return proto.CompactTextString(m) }
func (*Log_Query) ProtoMessage()    {}

func (m *Log_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Log_Query) GetMin() uint32 {
	if m != nil && m.Min != nil {
		return *m.Min
	}
	return 0
}

func (m *Log_Query) GetMax() uint32 {
	if m != nil && m.Max != nil {
		return *m.Max
	}
	return 0
}

type Log_List struct {
	// The server where the log entries are from.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The total number of logs entries on the server.
	Total *uint32 `protobuf:"varint,2,opt,name=total" json:"total,omitempty"`
	// The minimum log index that was sent.
	Min *uint32 `protobuf:"varint,3,opt,name=min" json:"min,omitempty"`
	// The maximum log index that was sent.
	Max *uint32 `protobuf:"varint,4,opt,name=max" json:"max,omitempty"`
	// The log entries.
	Entries          []*Log `protobuf:"bytes,5,rep,name=entries" json:"entries,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Log_List) Reset()         { *m = Log_List{} }
func (m *Log_List) String() string { return proto.CompactTextString(m) }
func (*Log_List) ProtoMessage()    {}

func (m *Log_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Log_List) GetTotal() uint32 {
	if m != nil && m.Total != nil {
		return *m.Total
	}
	return 0
}

func (m *Log_List) GetMin() uint32 {
	if m != nil && m.Min != nil {
		return *m.Min
	}
	return 0
}

func (m *Log_List) GetMax() uint32 {
	if m != nil && m.Max != nil {
		return *m.Max
	}
	return 0
}

func (m *Log_List) GetEntries() []*Log {
	if m != nil {
		return m.Entries
	}
	return nil
}

type Config struct {
	// The server for which the configuration is for.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The configuration keys and values.
	Fields           map[string]string `protobuf:"bytes,2,rep,name=fields" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *Config) Reset()         { *m = Config{} }
func (m *Config) String() string { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()    {}

func (m *Config) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Config) GetFields() map[string]string {
	if m != nil {
		return m.Fields
	}
	return nil
}

type Config_Field struct {
	// The server for which the configuration field is for.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The field key.
	Key *string `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	// The field value.
	Value            *string `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Config_Field) Reset()         { *m = Config_Field{} }
func (m *Config_Field) String() string { return proto.CompactTextString(m) }
func (*Config_Field) ProtoMessage()    {}

func (m *Config_Field) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Config_Field) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *Config_Field) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type Channel struct {
	// The server on which the channel exists.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The unique channel identifier.
	Id *uint32 `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	// The channel name.
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// The channel's parent.
	Parent *Channel `protobuf:"bytes,4,opt,name=parent" json:"parent,omitempty"`
	// Linked channels.
	Links []*Channel `protobuf:"bytes,5,rep,name=links" json:"links,omitempty"`
	// The channel's description.
	Description *string `protobuf:"bytes,6,opt,name=description" json:"description,omitempty"`
	// Is the channel temporary?
	Temporary *bool `protobuf:"varint,7,opt,name=temporary" json:"temporary,omitempty"`
	// The position in which the channel should appear in a sorted list.
	Position         *int32 `protobuf:"varint,8,opt,name=position" json:"position,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Channel) Reset()         { *m = Channel{} }
func (m *Channel) String() string { return proto.CompactTextString(m) }
func (*Channel) ProtoMessage()    {}

func (m *Channel) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Channel) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Channel) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Channel) GetParent() *Channel {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *Channel) GetLinks() []*Channel {
	if m != nil {
		return m.Links
	}
	return nil
}

func (m *Channel) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *Channel) GetTemporary() bool {
	if m != nil && m.Temporary != nil {
		return *m.Temporary
	}
	return false
}

func (m *Channel) GetPosition() int32 {
	if m != nil && m.Position != nil {
		return *m.Position
	}
	return 0
}

type Channel_Query struct {
	// The server on which the channels are.
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Channel_Query) Reset()         { *m = Channel_Query{} }
func (m *Channel_Query) String() string { return proto.CompactTextString(m) }
func (*Channel_Query) ProtoMessage()    {}

func (m *Channel_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

type Channel_List struct {
	// The server on which the channels are.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The channels.
	Channels         []*Channel `protobuf:"bytes,2,rep,name=channels" json:"channels,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *Channel_List) Reset()         { *m = Channel_List{} }
func (m *Channel_List) String() string { return proto.CompactTextString(m) }
func (*Channel_List) ProtoMessage()    {}

func (m *Channel_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Channel_List) GetChannels() []*Channel {
	if m != nil {
		return m.Channels
	}
	return nil
}

type User struct {
	// The server to which the user is connected.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The user's session ID.
	Session *uint32 `protobuf:"varint,2,opt,name=session" json:"session,omitempty"`
	// The user's registered ID.
	Id *uint32 `protobuf:"varint,3,opt,name=id" json:"id,omitempty"`
	// The user's name.
	Name *string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	// Is the user muted?
	Mute *bool `protobuf:"varint,5,opt,name=mute" json:"mute,omitempty"`
	// Is the user deafened?
	Deaf *bool `protobuf:"varint,6,opt,name=deaf" json:"deaf,omitempty"`
	// Is the user suppressed?
	Suppress *bool `protobuf:"varint,7,opt,name=suppress" json:"suppress,omitempty"`
	// Is the user a priority speaker?
	PrioritySpeaker *bool `protobuf:"varint,8,opt,name=priority_speaker" json:"priority_speaker,omitempty"`
	// Has the user muted him/herself?
	SelfMute *bool `protobuf:"varint,9,opt,name=self_mute" json:"self_mute,omitempty"`
	// Has the user muted him/herself?
	SelfDeaf *bool `protobuf:"varint,10,opt,name=self_deaf" json:"self_deaf,omitempty"`
	// Is the user recording?
	Recording *bool `protobuf:"varint,11,opt,name=recording" json:"recording,omitempty"`
	// The channel the user is in.
	Channel *Channel `protobuf:"bytes,12,opt,name=channel" json:"channel,omitempty"`
	// How long the user has been connected to the server.
	OnlineSecs *uint32 `protobuf:"varint,13,opt,name=online_secs" json:"online_secs,omitempty"`
	// How long the user has been idle on the server.
	IdleSecs *uint32 `protobuf:"varint,14,opt,name=idle_secs" json:"idle_secs,omitempty"`
	// How many bytes per second is the user transmitting to the server.
	BytesPerSec *uint32 `protobuf:"varint,15,opt,name=bytes_per_sec" json:"bytes_per_sec,omitempty"`
	// The user's client version.
	Version *Version `protobuf:"bytes,16,opt,name=version" json:"version,omitempty"`
	// The user's  plugin context.
	PluginContext []byte `protobuf:"bytes,17,opt,name=plugin_context" json:"plugin_context,omitempty"`
	// The user's plugin identity.
	PluginIdentity *string `protobuf:"bytes,18,opt,name=plugin_identity" json:"plugin_identity,omitempty"`
	// The user's comment.
	Comment *string `protobuf:"bytes,19,opt,name=comment" json:"comment,omitempty"`
	// The user's texture.
	Texture []byte `protobuf:"bytes,20,opt,name=texture" json:"texture,omitempty"`
	// The user's IP address.
	Address []byte `protobuf:"bytes,21,opt,name=address" json:"address,omitempty"`
	// Is the user in TCP-only mode?
	TcpOnly *bool `protobuf:"varint,22,opt,name=tcp_only" json:"tcp_only,omitempty"`
	// The user's UDP ping in milliseconds.
	UdpPingMsecs *float32 `protobuf:"fixed32,23,opt,name=udp_ping_msecs" json:"udp_ping_msecs,omitempty"`
	// The user's TCP ping in milliseconds.
	TcpPingMsecs     *float32 `protobuf:"fixed32,24,opt,name=tcp_ping_msecs" json:"tcp_ping_msecs,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}

func (m *User) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *User) GetSession() uint32 {
	if m != nil && m.Session != nil {
		return *m.Session
	}
	return 0
}

func (m *User) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *User) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *User) GetMute() bool {
	if m != nil && m.Mute != nil {
		return *m.Mute
	}
	return false
}

func (m *User) GetDeaf() bool {
	if m != nil && m.Deaf != nil {
		return *m.Deaf
	}
	return false
}

func (m *User) GetSuppress() bool {
	if m != nil && m.Suppress != nil {
		return *m.Suppress
	}
	return false
}

func (m *User) GetPrioritySpeaker() bool {
	if m != nil && m.PrioritySpeaker != nil {
		return *m.PrioritySpeaker
	}
	return false
}

func (m *User) GetSelfMute() bool {
	if m != nil && m.SelfMute != nil {
		return *m.SelfMute
	}
	return false
}

func (m *User) GetSelfDeaf() bool {
	if m != nil && m.SelfDeaf != nil {
		return *m.SelfDeaf
	}
	return false
}

func (m *User) GetRecording() bool {
	if m != nil && m.Recording != nil {
		return *m.Recording
	}
	return false
}

func (m *User) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *User) GetOnlineSecs() uint32 {
	if m != nil && m.OnlineSecs != nil {
		return *m.OnlineSecs
	}
	return 0
}

func (m *User) GetIdleSecs() uint32 {
	if m != nil && m.IdleSecs != nil {
		return *m.IdleSecs
	}
	return 0
}

func (m *User) GetBytesPerSec() uint32 {
	if m != nil && m.BytesPerSec != nil {
		return *m.BytesPerSec
	}
	return 0
}

func (m *User) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *User) GetPluginContext() []byte {
	if m != nil {
		return m.PluginContext
	}
	return nil
}

func (m *User) GetPluginIdentity() string {
	if m != nil && m.PluginIdentity != nil {
		return *m.PluginIdentity
	}
	return ""
}

func (m *User) GetComment() string {
	if m != nil && m.Comment != nil {
		return *m.Comment
	}
	return ""
}

func (m *User) GetTexture() []byte {
	if m != nil {
		return m.Texture
	}
	return nil
}

func (m *User) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *User) GetTcpOnly() bool {
	if m != nil && m.TcpOnly != nil {
		return *m.TcpOnly
	}
	return false
}

func (m *User) GetUdpPingMsecs() float32 {
	if m != nil && m.UdpPingMsecs != nil {
		return *m.UdpPingMsecs
	}
	return 0
}

func (m *User) GetTcpPingMsecs() float32 {
	if m != nil && m.TcpPingMsecs != nil {
		return *m.TcpPingMsecs
	}
	return 0
}

type User_Query struct {
	// The server whose users will be queried.
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *User_Query) Reset()         { *m = User_Query{} }
func (m *User_Query) String() string { return proto.CompactTextString(m) }
func (*User_Query) ProtoMessage()    {}

func (m *User_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

type User_List struct {
	// The server to which the users are connected.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The users.
	Users            []*User `protobuf:"bytes,2,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *User_List) Reset()         { *m = User_List{} }
func (m *User_List) String() string { return proto.CompactTextString(m) }
func (*User_List) ProtoMessage()    {}

func (m *User_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *User_List) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

type User_Kick struct {
	// The server to which the user is connected.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The user to kick.
	User *User `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	// The user who performed the kick.
	Actor *User `protobuf:"bytes,3,opt,name=actor" json:"actor,omitempty"`
	// The reason for why the user is being kicked.
	Reason           *string `protobuf:"bytes,4,opt,name=reason" json:"reason,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *User_Kick) Reset()         { *m = User_Kick{} }
func (m *User_Kick) String() string { return proto.CompactTextString(m) }
func (*User_Kick) ProtoMessage()    {}

func (m *User_Kick) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *User_Kick) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *User_Kick) GetActor() *User {
	if m != nil {
		return m.Actor
	}
	return nil
}

func (m *User_Kick) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

type Tree struct {
	// The server which the tree represents.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The current channel.
	Channel *Channel `protobuf:"bytes,2,opt,name=channel" json:"channel,omitempty"`
	// Channels below the current channel.
	Children []*Tree `protobuf:"bytes,3,rep,name=children" json:"children,omitempty"`
	// The users in the current channel.
	Users            []*User `protobuf:"bytes,4,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Tree) Reset()         { *m = Tree{} }
func (m *Tree) String() string { return proto.CompactTextString(m) }
func (*Tree) ProtoMessage()    {}

func (m *Tree) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Tree) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *Tree) GetChildren() []*Tree {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Tree) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

type Tree_Query struct {
	// The server to query.
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Tree_Query) Reset()         { *m = Tree_Query{} }
func (m *Tree_Query) String() string { return proto.CompactTextString(m) }
func (*Tree_Query) ProtoMessage()    {}

func (m *Tree_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

type Ban struct {
	// The server on which the ban is applied.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The banned IP address.
	Address []byte `protobuf:"bytes,2,opt,name=address" json:"address,omitempty"`
	// The number of leading bits in the address to which the ban applies.
	Bits *uint32 `protobuf:"varint,3,opt,name=bits" json:"bits,omitempty"`
	// The name of the banned user.
	Name *string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	// The certificate hash of the banned user.
	Hash *string `protobuf:"bytes,5,opt,name=hash" json:"hash,omitempty"`
	// The reason for the ban.
	Reason *string `protobuf:"bytes,6,opt,name=reason" json:"reason,omitempty"`
	// The ban start time (in epoch form).
	Start *int64 `protobuf:"varint,7,opt,name=start" json:"start,omitempty"`
	// The ban duration.
	DurationSecs     *int64 `protobuf:"varint,8,opt,name=duration_secs" json:"duration_secs,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Ban) Reset()         { *m = Ban{} }
func (m *Ban) String() string { return proto.CompactTextString(m) }
func (*Ban) ProtoMessage()    {}

func (m *Ban) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Ban) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *Ban) GetBits() uint32 {
	if m != nil && m.Bits != nil {
		return *m.Bits
	}
	return 0
}

func (m *Ban) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Ban) GetHash() string {
	if m != nil && m.Hash != nil {
		return *m.Hash
	}
	return ""
}

func (m *Ban) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

func (m *Ban) GetStart() int64 {
	if m != nil && m.Start != nil {
		return *m.Start
	}
	return 0
}

func (m *Ban) GetDurationSecs() int64 {
	if m != nil && m.DurationSecs != nil {
		return *m.DurationSecs
	}
	return 0
}

type Ban_Query struct {
	// The server whose bans to query.
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Ban_Query) Reset()         { *m = Ban_Query{} }
func (m *Ban_Query) String() string { return proto.CompactTextString(m) }
func (*Ban_Query) ProtoMessage()    {}

func (m *Ban_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

type Ban_List struct {
	// The server for which the bans apply.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The bans.
	Bans             []*Ban `protobuf:"bytes,2,rep,name=bans" json:"bans,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Ban_List) Reset()         { *m = Ban_List{} }
func (m *Ban_List) String() string { return proto.CompactTextString(m) }
func (*Ban_List) ProtoMessage()    {}

func (m *Ban_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Ban_List) GetBans() []*Ban {
	if m != nil {
		return m.Bans
	}
	return nil
}

type ACL struct {
	// Does the ACL apply to the current channel?
	ApplyHere *bool `protobuf:"varint,3,opt,name=apply_here" json:"apply_here,omitempty"`
	// Does the ACL apply to the current channel's sub-channels?
	ApplySubs *bool `protobuf:"varint,4,opt,name=apply_subs" json:"apply_subs,omitempty"`
	// Was the ACL inherited?
	Inherited *bool `protobuf:"varint,5,opt,name=inherited" json:"inherited,omitempty"`
	// The user to whom the ACL applies.
	User *DatabaseUser `protobuf:"bytes,6,opt,name=user" json:"user,omitempty"`
	// The group to whom the ACL applies.
	Group *ACL_Group `protobuf:"bytes,7,opt,name=group" json:"group,omitempty"`
	// The permissions granted by the ACL (bitmask of ACL.Permission).
	Allow *uint32 `protobuf:"varint,8,opt,name=allow" json:"allow,omitempty"`
	// The permissions denied by the ACL (bitmask of ACL.Permission).
	Deny             *uint32 `protobuf:"varint,9,opt,name=deny" json:"deny,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ACL) Reset()         { *m = ACL{} }
func (m *ACL) String() string { return proto.CompactTextString(m) }
func (*ACL) ProtoMessage()    {}

func (m *ACL) GetApplyHere() bool {
	if m != nil && m.ApplyHere != nil {
		return *m.ApplyHere
	}
	return false
}

func (m *ACL) GetApplySubs() bool {
	if m != nil && m.ApplySubs != nil {
		return *m.ApplySubs
	}
	return false
}

func (m *ACL) GetInherited() bool {
	if m != nil && m.Inherited != nil {
		return *m.Inherited
	}
	return false
}

func (m *ACL) GetUser() *DatabaseUser {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ACL) GetGroup() *ACL_Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *ACL) GetAllow() uint32 {
	if m != nil && m.Allow != nil {
		return *m.Allow
	}
	return 0
}

func (m *ACL) GetDeny() uint32 {
	if m != nil && m.Deny != nil {
		return *m.Deny
	}
	return 0
}

type ACL_Group struct {
	// The ACL group name.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Is the group inherited?
	Inherited *bool `protobuf:"varint,2,opt,name=inherited" json:"inherited,omitempty"`
	// Does the group inherit members?
	Inherit *bool `protobuf:"varint,3,opt,name=inherit" json:"inherit,omitempty"`
	// Can this group be inherited by its children?
	Inheritable *bool `protobuf:"varint,4,opt,name=inheritable" json:"inheritable,omitempty"`
	// The users explicitly added by this group.
	UsersAdd []*DatabaseUser `protobuf:"bytes,5,rep,name=users_add" json:"users_add,omitempty"`
	// The users explicitly removed by this group.
	UsersRemove []*DatabaseUser `protobuf:"bytes,6,rep,name=users_remove" json:"users_remove,omitempty"`
	// All of the users who are part of this group.
	Users            []*DatabaseUser `protobuf:"bytes,7,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *ACL_Group) Reset()         { *m = ACL_Group{} }
func (m *ACL_Group) String() string { return proto.CompactTextString(m) }
func (*ACL_Group) ProtoMessage()    {}

func (m *ACL_Group) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ACL_Group) GetInherited() bool {
	if m != nil && m.Inherited != nil {
		return *m.Inherited
	}
	return false
}

func (m *ACL_Group) GetInherit() bool {
	if m != nil && m.Inherit != nil {
		return *m.Inherit
	}
	return false
}

func (m *ACL_Group) GetInheritable() bool {
	if m != nil && m.Inheritable != nil {
		return *m.Inheritable
	}
	return false
}

func (m *ACL_Group) GetUsersAdd() []*DatabaseUser {
	if m != nil {
		return m.UsersAdd
	}
	return nil
}

func (m *ACL_Group) GetUsersRemove() []*DatabaseUser {
	if m != nil {
		return m.UsersRemove
	}
	return nil
}

func (m *ACL_Group) GetUsers() []*DatabaseUser {
	if m != nil {
		return m.Users
	}
	return nil
}

type ACL_Query struct {
	// The server where the user and channel exist.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The user to query.
	User *User `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	// The channel to query.
	Channel          *Channel `protobuf:"bytes,3,opt,name=channel" json:"channel,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ACL_Query) Reset()         { *m = ACL_Query{} }
func (m *ACL_Query) String() string { return proto.CompactTextString(m) }
func (*ACL_Query) ProtoMessage()    {}

func (m *ACL_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *ACL_Query) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ACL_Query) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

type ACL_List struct {
	// The server on which the ACLs exist.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The channel to which the ACL refers.
	Channel *Channel `protobuf:"bytes,2,opt,name=channel" json:"channel,omitempty"`
	// The ACLs part of the given channel.
	Acls []*ACL `protobuf:"bytes,3,rep,name=acls" json:"acls,omitempty"`
	// The groups part of the given channel.
	Groups []*ACL_Group `protobuf:"bytes,4,rep,name=groups" json:"groups,omitempty"`
	// Should ACLs be inherited from the parent channel.
	Inherit          *bool  `protobuf:"varint,5,opt,name=inherit" json:"inherit,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ACL_List) Reset()         { *m = ACL_List{} }
func (m *ACL_List) String() string { return proto.CompactTextString(m) }
func (*ACL_List) ProtoMessage()    {}

func (m *ACL_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *ACL_List) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *ACL_List) GetAcls() []*ACL {
	if m != nil {
		return m.Acls
	}
	return nil
}

func (m *ACL_List) GetGroups() []*ACL_Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *ACL_List) GetInherit() bool {
	if m != nil && m.Inherit != nil {
		return *m.Inherit
	}
	return false
}

type ACL_TemporaryGroup struct {
	// The server where the temporary group exists.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The channel to which the temporary user group is added.
	Channel *Channel `protobuf:"bytes,2,opt,name=channel" json:"channel,omitempty"`
	// The user who is added to the group.
	User *User `protobuf:"bytes,3,opt,name=user" json:"user,omitempty"`
	// The name of the temporary group.
	Name             *string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ACL_TemporaryGroup) Reset()         { *m = ACL_TemporaryGroup{} }
func (m *ACL_TemporaryGroup) String() string { return proto.CompactTextString(m) }
func (*ACL_TemporaryGroup) ProtoMessage()    {}

func (m *ACL_TemporaryGroup) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *ACL_TemporaryGroup) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *ACL_TemporaryGroup) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ACL_TemporaryGroup) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

type Authenticator struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Authenticator) Reset()         { *m = Authenticator{} }
func (m *Authenticator) String() string { return proto.CompactTextString(m) }
func (*Authenticator) ProtoMessage()    {}

type Authenticator_Request struct {
	Authenticate     *Authenticator_Request_Authenticate `protobuf:"bytes,1,opt,name=authenticate" json:"authenticate,omitempty"`
	Find             *Authenticator_Request_Find         `protobuf:"bytes,2,opt,name=find" json:"find,omitempty"`
	Query            *Authenticator_Request_Query        `protobuf:"bytes,3,opt,name=query" json:"query,omitempty"`
	Register         *Authenticator_Request_Register     `protobuf:"bytes,4,opt,name=register" json:"register,omitempty"`
	Deregister       *Authenticator_Request_Deregister   `protobuf:"bytes,5,opt,name=deregister" json:"deregister,omitempty"`
	Update           *Authenticator_Request_Update       `protobuf:"bytes,6,opt,name=update" json:"update,omitempty"`
	XXX_unrecognized []byte                              `json:"-"`
}

func (m *Authenticator_Request) Reset()         { *m = Authenticator_Request{} }
func (m *Authenticator_Request) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request) ProtoMessage()    {}

func (m *Authenticator_Request) GetAuthenticate() *Authenticator_Request_Authenticate {
	if m != nil {
		return m.Authenticate
	}
	return nil
}

func (m *Authenticator_Request) GetFind() *Authenticator_Request_Find {
	if m != nil {
		return m.Find
	}
	return nil
}

func (m *Authenticator_Request) GetQuery() *Authenticator_Request_Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *Authenticator_Request) GetRegister() *Authenticator_Request_Register {
	if m != nil {
		return m.Register
	}
	return nil
}

func (m *Authenticator_Request) GetDeregister() *Authenticator_Request_Deregister {
	if m != nil {
		return m.Deregister
	}
	return nil
}

func (m *Authenticator_Request) GetUpdate() *Authenticator_Request_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

// An authentication request for a connecting user.
type Authenticator_Request_Authenticate struct {
	// The user's name.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The user's password.
	Password *string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
	// The user's certificate chain in DER format.
	Certificates [][]byte `protobuf:"bytes,3,rep,name=certificates" json:"certificates,omitempty"`
	// The hexadecimal hash of the user's certificate.
	CertificateHash *string `protobuf:"bytes,4,opt,name=certificate_hash" json:"certificate_hash,omitempty"`
	// If the user is connecting with a strong certificate.
	StrongCertificate *bool  `protobuf:"varint,5,opt,name=strong_certificate" json:"strong_certificate,omitempty"`
	XXX_unrecognized  []byte `json:"-"`
}

func (m *Authenticator_Request_Authenticate) Reset()         { *m = Authenticator_Request_Authenticate{} }
func (m *Authenticator_Request_Authenticate) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request_Authenticate) ProtoMessage()    {}

func (m *Authenticator_Request_Authenticate) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Authenticator_Request_Authenticate) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *Authenticator_Request_Authenticate) GetCertificates() [][]byte {
	if m != nil {
		return m.Certificates
	}
	return nil
}

func (m *Authenticator_Request_Authenticate) GetCertificateHash() string {
	if m != nil && m.CertificateHash != nil {
		return *m.CertificateHash
	}
	return ""
}

func (m *Authenticator_Request_Authenticate) GetStrongCertificate() bool {
	if m != nil && m.StrongCertificate != nil {
		return *m.StrongCertificate
	}
	return false
}

// A request for information about a user, given by either the user's ID
// or name.
type Authenticator_Request_Find struct {
	// The user's ID used for lookup.
	Id *uint32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// The user's name used for lookup.
	Name             *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Authenticator_Request_Find) Reset()         { *m = Authenticator_Request_Find{} }
func (m *Authenticator_Request_Find) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request_Find) ProtoMessage()    {}

func (m *Authenticator_Request_Find) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Authenticator_Request_Find) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

// A query of all the registered users, optionally filtered by the given
// filter string.
type Authenticator_Request_Query struct {
	// A user name filter (% is often used as a wildcard)
	Filter           *string `protobuf:"bytes,1,opt,name=filter" json:"filter,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Authenticator_Request_Query) Reset()         { *m = Authenticator_Request_Query{} }
func (m *Authenticator_Request_Query) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request_Query) ProtoMessage()    {}

func (m *Authenticator_Request_Query) GetFilter() string {
	if m != nil && m.Filter != nil {
		return *m.Filter
	}
	return ""
}

// A request for a new user registration.
type Authenticator_Request_Register struct {
	// The database user to register.
	User             *DatabaseUser `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Authenticator_Request_Register) Reset()         { *m = Authenticator_Request_Register{} }
func (m *Authenticator_Request_Register) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request_Register) ProtoMessage()    {}

func (m *Authenticator_Request_Register) GetUser() *DatabaseUser {
	if m != nil {
		return m.User
	}
	return nil
}

// A request for deregistering a registered user.
type Authenticator_Request_Deregister struct {
	// The database user to deregister.
	User             *DatabaseUser `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Authenticator_Request_Deregister) Reset()         { *m = Authenticator_Request_Deregister{} }
func (m *Authenticator_Request_Deregister) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request_Deregister) ProtoMessage()    {}

func (m *Authenticator_Request_Deregister) GetUser() *DatabaseUser {
	if m != nil {
		return m.User
	}
	return nil
}

// A request to update a registered user's information. The information
// provided should be merged with existing data.
type Authenticator_Request_Update struct {
	// The database user to update.
	User             *DatabaseUser `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Authenticator_Request_Update) Reset()         { *m = Authenticator_Request_Update{} }
func (m *Authenticator_Request_Update) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request_Update) ProtoMessage()    {}

func (m *Authenticator_Request_Update) GetUser() *DatabaseUser {
	if m != nil {
		return m.User
	}
	return nil
}

type Authenticator_Response struct {
	Initialize       *Authenticator_Response_Initialize   `protobuf:"bytes,1,opt,name=initialize" json:"initialize,omitempty"`
	Authenticate     *Authenticator_Response_Authenticate `protobuf:"bytes,2,opt,name=authenticate" json:"authenticate,omitempty"`
	Find             *Authenticator_Response_Find         `protobuf:"bytes,3,opt,name=find" json:"find,omitempty"`
	Query            *Authenticator_Response_Query        `protobuf:"bytes,4,opt,name=query" json:"query,omitempty"`
	Register         *Authenticator_Response_Register     `protobuf:"bytes,5,opt,name=register" json:"register,omitempty"`
	Deregister       *Authenticator_Response_Deregister   `protobuf:"bytes,6,opt,name=deregister" json:"deregister,omitempty"`
	Update           *Authenticator_Response_Update       `protobuf:"bytes,7,opt,name=update" json:"update,omitempty"`
	XXX_unrecognized []byte                               `json:"-"`
}

func (m *Authenticator_Response) Reset()         { *m = Authenticator_Response{} }
func (m *Authenticator_Response) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response) ProtoMessage()    {}

func (m *Authenticator_Response) GetInitialize() *Authenticator_Response_Initialize {
	if m != nil {
		return m.Initialize
	}
	return nil
}

func (m *Authenticator_Response) GetAuthenticate() *Authenticator_Response_Authenticate {
	if m != nil {
		return m.Authenticate
	}
	return nil
}

func (m *Authenticator_Response) GetFind() *Authenticator_Response_Find {
	if m != nil {
		return m.Find
	}
	return nil
}

func (m *Authenticator_Response) GetQuery() *Authenticator_Response_Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *Authenticator_Response) GetRegister() *Authenticator_Response_Register {
	if m != nil {
		return m.Register
	}
	return nil
}

func (m *Authenticator_Response) GetDeregister() *Authenticator_Response_Deregister {
	if m != nil {
		return m.Deregister
	}
	return nil
}

func (m *Authenticator_Response) GetUpdate() *Authenticator_Response_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

// The initialization for the authenticator stream. This message must be
// sent before authentication requests will start streaming.
type Authenticator_Response_Initialize struct {
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Authenticator_Response_Initialize) Reset()         { *m = Authenticator_Response_Initialize{} }
func (m *Authenticator_Response_Initialize) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Initialize) ProtoMessage()    {}

func (m *Authenticator_Response_Initialize) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

type Authenticator_Response_Authenticate struct {
	// The status of the request.
	Status *Authenticator_Response_Status `protobuf:"varint,1,opt,name=status,enum=MurmurRPC.Authenticator_Response_Status" json:"status,omitempty"`
	// The user's registered ID.
	Id *uint32 `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	// The corrected user's name;
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// Additional ACL groups that the user belongs too.
	Groups           []*ACL_Group `protobuf:"bytes,4,rep,name=groups" json:"groups,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *Authenticator_Response_Authenticate) Reset()         { *m = Authenticator_Response_Authenticate{} }
func (m *Authenticator_Response_Authenticate) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Authenticate) ProtoMessage()    {}

func (m *Authenticator_Response_Authenticate) GetStatus() Authenticator_Response_Status {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Authenticator_Response_Fallthrough
}

func (m *Authenticator_Response_Authenticate) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Authenticator_Response_Authenticate) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Authenticator_Response_Authenticate) GetGroups() []*ACL_Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

type Authenticator_Response_Find struct {
	// The database user (if found).
	User             *DatabaseUser `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Authenticator_Response_Find) Reset()         { *m = Authenticator_Response_Find{} }
func (m *Authenticator_Response_Find) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Find) ProtoMessage()    {}

func (m *Authenticator_Response_Find) GetUser() *DatabaseUser {
	if m != nil {
		return m.User
	}
	return nil
}

type Authenticator_Response_Query struct {
	// The matched database users.
	Users            []*DatabaseUser `protobuf:"bytes,1,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Authenticator_Response_Query) Reset()         { *m = Authenticator_Response_Query{} }
func (m *Authenticator_Response_Query) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Query) ProtoMessage()    {}

func (m *Authenticator_Response_Query) GetUsers() []*DatabaseUser {
	if m != nil {
		return m.Users
	}
	return nil
}

type Authenticator_Response_Register struct {
	// The status of the request.
	Status *Authenticator_Response_Status `protobuf:"varint,1,opt,name=status,enum=MurmurRPC.Authenticator_Response_Status" json:"status,omitempty"`
	// The registered database user (must contain the registered user's ID).
	User             *DatabaseUser `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Authenticator_Response_Register) Reset()         { *m = Authenticator_Response_Register{} }
func (m *Authenticator_Response_Register) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Register) ProtoMessage()    {}

func (m *Authenticator_Response_Register) GetStatus() Authenticator_Response_Status {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Authenticator_Response_Fallthrough
}

func (m *Authenticator_Response_Register) GetUser() *DatabaseUser {
	if m != nil {
		return m.User
	}
	return nil
}

type Authenticator_Response_Deregister struct {
	// The status of the request.
	Status           *Authenticator_Response_Status `protobuf:"varint,1,opt,name=status,enum=MurmurRPC.Authenticator_Response_Status" json:"status,omitempty"`
	XXX_unrecognized []byte                         `json:"-"`
}

func (m *Authenticator_Response_Deregister) Reset()         { *m = Authenticator_Response_Deregister{} }
func (m *Authenticator_Response_Deregister) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Deregister) ProtoMessage()    {}

func (m *Authenticator_Response_Deregister) GetStatus() Authenticator_Response_Status {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Authenticator_Response_Fallthrough
}

type Authenticator_Response_Update struct {
	// The status of the request.
	Status           *Authenticator_Response_Status `protobuf:"varint,1,opt,name=status,enum=MurmurRPC.Authenticator_Response_Status" json:"status,omitempty"`
	XXX_unrecognized []byte                         `json:"-"`
}

func (m *Authenticator_Response_Update) Reset()         { *m = Authenticator_Response_Update{} }
func (m *Authenticator_Response_Update) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Update) ProtoMessage()    {}

func (m *Authenticator_Response_Update) GetStatus() Authenticator_Response_Status {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Authenticator_Response_Fallthrough
}

type DatabaseUser struct {
	// The server on which the user is registered.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The unique user ID.
	Id *uint32 `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	// The user's name.
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// The user's email address.
	Email *string `protobuf:"bytes,4,opt,name=email" json:"email,omitempty"`
	// The user's comment.
	Comment *string `protobuf:"bytes,5,opt,name=comment" json:"comment,omitempty"`
	// The user's certificate hash.
	Hash *string `protobuf:"bytes,6,opt,name=hash" json:"hash,omitempty"`
	// The user's password (never sent; used only when updating).
	Password *string `protobuf:"bytes,7,opt,name=password" json:"password,omitempty"`
	// When the user was last on the server.
	LastActive *string `protobuf:"bytes,8,opt,name=last_active" json:"last_active,omitempty"`
	// The user's texture.
	Texture          []byte `protobuf:"bytes,9,opt,name=texture" json:"texture,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *DatabaseUser) Reset()         { *m = DatabaseUser{} }
func (m *DatabaseUser) String() string { return proto.CompactTextString(m) }
func (*DatabaseUser) ProtoMessage()    {}

func (m *DatabaseUser) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *DatabaseUser) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *DatabaseUser) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *DatabaseUser) GetEmail() string {
	if m != nil && m.Email != nil {
		return *m.Email
	}
	return ""
}

func (m *DatabaseUser) GetComment() string {
	if m != nil && m.Comment != nil {
		return *m.Comment
	}
	return ""
}

func (m *DatabaseUser) GetHash() string {
	if m != nil && m.Hash != nil {
		return *m.Hash
	}
	return ""
}

func (m *DatabaseUser) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *DatabaseUser) GetLastActive() string {
	if m != nil && m.LastActive != nil {
		return *m.LastActive
	}
	return ""
}

func (m *DatabaseUser) GetTexture() []byte {
	if m != nil {
		return m.Texture
	}
	return nil
}

type DatabaseUser_Query struct {
	// The server whose users will be queried.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// A string to filter the users by.
	Filter           *string `protobuf:"bytes,2,opt,name=filter" json:"filter,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DatabaseUser_Query) Reset()         { *m = DatabaseUser_Query{} }
func (m *DatabaseUser_Query) String() string { return proto.CompactTextString(m) }
func (*DatabaseUser_Query) ProtoMessage()    {}

func (m *DatabaseUser_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *DatabaseUser_Query) GetFilter() string {
	if m != nil && m.Filter != nil {
		return *m.Filter
	}
	return ""
}

type DatabaseUser_List struct {
	// The server on which the users are registered.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The users.
	Users            []*DatabaseUser `protobuf:"bytes,2,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *DatabaseUser_List) Reset()         { *m = DatabaseUser_List{} }
func (m *DatabaseUser_List) String() string { return proto.CompactTextString(m) }
func (*DatabaseUser_List) ProtoMessage()    {}

func (m *DatabaseUser_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *DatabaseUser_List) GetUsers() []*DatabaseUser {
	if m != nil {
		return m.Users
	}
	return nil
}

type DatabaseUser_Verify struct {
	// The server on which the user-password pair will be authenticated.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The user's name.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The user's password.
	Password         *string `protobuf:"bytes,3,opt,name=password" json:"password,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DatabaseUser_Verify) Reset()         { *m = DatabaseUser_Verify{} }
func (m *DatabaseUser_Verify) String() string { return proto.CompactTextString(m) }
func (*DatabaseUser_Verify) ProtoMessage()    {}

func (m *DatabaseUser_Verify) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *DatabaseUser_Verify) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *DatabaseUser_Verify) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

type RedirectWhisperGroup struct {
	// The server on which the whisper redirection will take place.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The user to whom the redirection will be applied.
	User *User `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	// The source group.
	Source *ACL_Group `protobuf:"bytes,3,opt,name=source" json:"source,omitempty"`
	// The target group.
	Target           *ACL_Group `protobuf:"bytes,4,opt,name=target" json:"target,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *RedirectWhisperGroup) Reset()         { *m = RedirectWhisperGroup{} }
func (m *RedirectWhisperGroup) String() string { return proto.CompactTextString(m) }
func (*RedirectWhisperGroup) ProtoMessage()    {}

func (m *RedirectWhisperGroup) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *RedirectWhisperGroup) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *RedirectWhisperGroup) GetSource() *ACL_Group {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *RedirectWhisperGroup) GetTarget() *ACL_Group {
	if m != nil {
		return m.Target
	}
	return nil
}

func init() {
	proto.RegisterEnum("MurmurRPC.Server_Event_Type", Server_Event_Type_name, Server_Event_Type_value)
	proto.RegisterEnum("MurmurRPC.Event_Type", Event_Type_name, Event_Type_value)
	proto.RegisterEnum("MurmurRPC.ContextAction_Context", ContextAction_Context_name, ContextAction_Context_value)
	proto.RegisterEnum("MurmurRPC.TextMessage_Filter_Action", TextMessage_Filter_Action_name, TextMessage_Filter_Action_value)
	proto.RegisterEnum("MurmurRPC.ACL_Permission", ACL_Permission_name, ACL_Permission_value)
	proto.RegisterEnum("MurmurRPC.Authenticator_Response_Status", Authenticator_Response_Status_name, Authenticator_Response_Status_value)
}

// Client API for V1 service

type V1Client interface {
	// GetUptime returns murmur's uptime.
	GetUptime(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Uptime, error)
	// GetVersion returns murmur's version.
	GetVersion(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Version, error)
	// Events returns a stream of murmur events.
	Events(ctx context.Context, in *Void, opts ...grpc.CallOption) (V1_EventsClient, error)
	// ServerCreate creates a new virtual server. The returned server object
	// contains the newly created server's ID.
	ServerCreate(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Server, error)
	// ServerQuery returns a list of servers that match the given query.
	ServerQuery(ctx context.Context, in *Server_Query, opts ...grpc.CallOption) (*Server_List, error)
	// ServerGet returns information about the given server.
	ServerGet(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Server, error)
	// ServerStart starts the given stopped server.
	ServerStart(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error)
	// ServerStop stops the given virtual server.
	ServerStop(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error)
	// ServerRemove removes the given virtual server and its configuration.
	ServerRemove(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error)
	// ServerEvents returns a stream of events that happen on the given server.
	ServerEvents(ctx context.Context, in *Server, opts ...grpc.CallOption) (V1_ServerEventsClient, error)
	// ContextActionAdd adds a context action to the given user's client. The
	// following ContextAction fields must be set:
	//   context, action, text, and user.
	//
	// Added context actions are valid until:
	//  - The context action is removed with ContextActionRemove, or
	//  - The user disconnects from the server, or
	//  - The server stops.
	ContextActionAdd(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error)
	// ContextActionRemove removes a context action from the given user's client.
	// The following ContextAction must be set:
	//   action
	// If no user is given, the context action is removed from all users.
	ContextActionRemove(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error)
	// ContextActionEvents returns a stream of context action events that are
	// triggered by users.
	ContextActionEvents(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (V1_ContextActionEventsClient, error)
	// TextMessageSend sends the given TextMessage to the server.
	//
	// If no users, channels, or trees are added to the TextMessage, the message
	// will be broadcast the entire server. Otherwise, the message will be
	// targeted to the specified users, channels, and trees.
	TextMessageSend(ctx context.Context, in *TextMessage, opts ...grpc.CallOption) (*Void, error)
	// TextMessageFilter filters text messages on a given server.
	TextMessageFilter(ctx context.Context, opts ...grpc.CallOption) (V1_TextMessageFilterClient, error)
	// LogQuery returns a list of log entries from the given server.
	//
	// To get the total number of log entries, omit min and/or max from the
	// query.
	LogQuery(ctx context.Context, in *Log_Query, opts ...grpc.CallOption) (*Log_List, error)
	// ConfigGet returns the explicitly set configuration for the given server.
	ConfigGet(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Config, error)
	// ConfigGetField returns the configuration value for the given key.
	ConfigGetField(ctx context.Context, in *Config_Field, opts ...grpc.CallOption) (*Config_Field, error)
	// ConfigSetField sets the configuration value to the given value.
	ConfigSetField(ctx context.Context, in *Config_Field, opts ...grpc.CallOption) (*Void, error)
	// ConfigGetDefault returns the default server configuration.
	ConfigGetDefault(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Config, error)
	// ChannelQuery returns a list of channels that match the given query.
	ChannelQuery(ctx context.Context, in *Channel_Query, opts ...grpc.CallOption) (*Channel_List, error)
	// ChannelGet returns the channel with the given ID.
	ChannelGet(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error)
	// ChannelAdd adds the channel to the given server. The parent and name of
	// the channel must be set.
	ChannelAdd(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error)
	// ChannelRemove removes the given channel from the server.
	ChannelRemove(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Void, error)
	// ChannelUpdate updates the given channel's attributes. Only the fields that
	// are set will be updated.
	ChannelUpdate(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error)
	// UserQuery returns a list of connected users who match the given query.
	UserQuery(ctx context.Context, in *User_Query, opts ...grpc.CallOption) (*User_List, error)
	// UserGet returns information on the connected user, given by the user's
	// session or name.
	UserGet(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	// UserUpdate changes the given user's state. Only the following fields can
	// be changed:
	//   name, mute, deaf, suppress, priority_speaker, channel, comment.
	UserUpdate(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	// UserKick kicks the user from the server.
	UserKick(ctx context.Context, in *User_Kick, opts ...grpc.CallOption) (*Void, error)
	// TreeQuery returns a representation of the given server's channel/user
	// tree.
	TreeQuery(ctx context.Context, in *Tree_Query, opts ...grpc.CallOption) (*Tree, error)
	// BansGet returns a list of bans for the given server.
	BansGet(ctx context.Context, in *Ban_Query, opts ...grpc.CallOption) (*Ban_List, error)
	// BansSet replaces the server's ban list with the given list.
	BansSet(ctx context.Context, in *Ban_List, opts ...grpc.CallOption) (*Void, error)
	// ACLGet returns the ACL for the given channel.
	ACLGet(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*ACL_List, error)
	// ACLSet overrides the ACL of the given channel to what is provided.
	ACLSet(ctx context.Context, in *ACL_List, opts ...grpc.CallOption) (*Void, error)
	// ACLGetEffectivePermissions returns the effective permissions for the given
	// user in the given channel.
	ACLGetEffectivePermissions(ctx context.Context, in *ACL_Query, opts ...grpc.CallOption) (*ACL, error)
	// ACLAddTemporaryGroup adds a user to a temporary group.
	ACLAddTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error)
	// ACLRemoveTemporaryGroup removes a user from a temporary group.
	ACLRemoveTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error)
	// AuthenticatorStream opens an authentication stream to the server.
	//
	// There can only be one RPC client with an open Stream. If a new
	// authenticator connects, the open connected will be closed.
	AuthenticatorStream(ctx context.Context, opts ...grpc.CallOption) (V1_AuthenticatorStreamClient, error)
	// DatabaseUserQuery returns a list of registered users who match given
	// query.
	DatabaseUserQuery(ctx context.Context, in *DatabaseUser_Query, opts ...grpc.CallOption) (*DatabaseUser_List, error)
	// DatabaseUserGet returns the database user with the given ID.
	DatabaseUserGet(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error)
	// DatabaseUserUpdate updates the given database user.
	DatabaseUserUpdate(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error)
	// DatabaseUserRegister registers a user with the given information on the
	// server. The returned DatabaseUser will contain the newly registered user's
	// ID.
	DatabaseUserRegister(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error)
	// DatabaseUserDeregister deregisters the given user.
	DatabaseUserDeregister(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error)
	// DatabaseUserVerify verifies the that the given user-password pair is
	// correct.
	DatabaseUserVerify(ctx context.Context, in *DatabaseUser_Verify, opts ...grpc.CallOption) (*DatabaseUser, error)
	// AddRedirectWhisperGroup add a whisper targets redirection for the given
	// user. Whenever a user whispers to group "source", the whisper will be
	// redirected to group "target".
	RedirectWhisperGroupAdd(ctx context.Context, in *RedirectWhisperGroup, opts ...grpc.CallOption) (*Void, error)
	// RemoveRedirectWhisperGroup removes a whisper target redirection for
	// the the given user.
	RedirectWhisperGroupRemove(ctx context.Context, in *RedirectWhisperGroup, opts ...grpc.CallOption) (*Void, error)
}

type v1Client struct {
	cc *grpc.ClientConn
}

func NewV1Client(cc *grpc.ClientConn) V1Client {
	return &v1Client{cc}
}

func (c *v1Client) GetUptime(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Uptime, error) {
	out := new(Uptime)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/GetUptime", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) GetVersion(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Version, error) {
	out := new(Version)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/GetVersion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) Events(ctx context.Context, in *Void, opts ...grpc.CallOption) (V1_EventsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_V1_serviceDesc.Streams[0], c.cc, "/MurmurRPC.V1/Events", opts...)
	if err != nil {
		return nil, err
	}
	x := &v1EventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type V1_EventsClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type v1EventsClient struct {
	grpc.ClientStream
}

func (x *v1EventsClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *v1Client) ServerCreate(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Server, error) {
	out := new(Server)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ServerCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ServerQuery(ctx context.Context, in *Server_Query, opts ...grpc.CallOption) (*Server_List, error) {
	out := new(Server_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ServerQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ServerGet(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Server, error) {
	out := new(Server)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ServerGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ServerStart(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ServerStart", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ServerStop(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ServerStop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ServerRemove(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ServerRemove", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ServerEvents(ctx context.Context, in *Server, opts ...grpc.CallOption) (V1_ServerEventsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_V1_serviceDesc.Streams[1], c.cc, "/MurmurRPC.V1/ServerEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &v1ServerEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type V1_ServerEventsClient interface {
	Recv() (*Server_Event, error)
	grpc.ClientStream
}

type v1ServerEventsClient struct {
	grpc.ClientStream
}

func (x *v1ServerEventsClient) Recv() (*Server_Event, error) {
	m := new(Server_Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *v1Client) ContextActionAdd(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ContextActionAdd", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ContextActionRemove(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ContextActionRemove", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ContextActionEvents(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (V1_ContextActionEventsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_V1_serviceDesc.Streams[2], c.cc, "/MurmurRPC.V1/ContextActionEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &v1ContextActionEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type V1_ContextActionEventsClient interface {
	Recv() (*ContextAction, error)
	grpc.ClientStream
}

type v1ContextActionEventsClient struct {
	grpc.ClientStream
}

func (x *v1ContextActionEventsClient) Recv() (*ContextAction, error) {
	m := new(ContextAction)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *v1Client) TextMessageSend(ctx context.Context, in *TextMessage, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/TextMessageSend", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) TextMessageFilter(ctx context.Context, opts ...grpc.CallOption) (V1_TextMessageFilterClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_V1_serviceDesc.Streams[3], c.cc, "/MurmurRPC.V1/TextMessageFilter", opts...)
	if err != nil {
		return nil, err
	}
	x := &v1TextMessageFilterClient{stream}
	return x, nil
}

type V1_TextMessageFilterClient interface {
	Send(*TextMessage_Filter) error
	Recv() (*TextMessage_Filter, error)
	grpc.ClientStream
}

type v1TextMessageFilterClient struct {
	grpc.ClientStream
}

func (x *v1TextMessageFilterClient) Send(m *TextMessage_Filter) error {
	return x.ClientStream.SendMsg(m)
}

func (x *v1TextMessageFilterClient) Recv() (*TextMessage_Filter, error) {
	m := new(TextMessage_Filter)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *v1Client) LogQuery(ctx context.Context, in *Log_Query, opts ...grpc.CallOption) (*Log_List, error) {
	out := new(Log_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/LogQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ConfigGet(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Config, error) {
	out := new(Config)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ConfigGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ConfigGetField(ctx context.Context, in *Config_Field, opts ...grpc.CallOption) (*Config_Field, error) {
	out := new(Config_Field)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ConfigGetField", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ConfigSetField(ctx context.Context, in *Config_Field, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ConfigSetField", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ConfigGetDefault(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Config, error) {
	out := new(Config)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ConfigGetDefault", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ChannelQuery(ctx context.Context, in *Channel_Query, opts ...grpc.CallOption) (*Channel_List, error) {
	out := new(Channel_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ChannelQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ChannelGet(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error) {
	out := new(Channel)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ChannelGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ChannelAdd(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error) {
	out := new(Channel)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ChannelAdd", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ChannelRemove(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ChannelRemove", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ChannelUpdate(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error) {
	out := new(Channel)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ChannelUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) UserQuery(ctx context.Context, in *User_Query, opts ...grpc.CallOption) (*User_List, error) {
	out := new(User_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/UserQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) UserGet(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/UserGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) UserUpdate(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/UserUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) UserKick(ctx context.Context, in *User_Kick, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/UserKick", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) TreeQuery(ctx context.Context, in *Tree_Query, opts ...grpc.CallOption) (*Tree, error) {
	out := new(Tree)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/TreeQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) BansGet(ctx context.Context, in *Ban_Query, opts ...grpc.CallOption) (*Ban_List, error) {
	out := new(Ban_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/BansGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) BansSet(ctx context.Context, in *Ban_List, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/BansSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ACLGet(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*ACL_List, error) {
	out := new(ACL_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ACLGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ACLSet(ctx context.Context, in *ACL_List, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ACLSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ACLGetEffectivePermissions(ctx context.Context, in *ACL_Query, opts ...grpc.CallOption) (*ACL, error) {
	out := new(ACL)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ACLGetEffectivePermissions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ACLAddTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ACLAddTemporaryGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ACLRemoveTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ACLRemoveTemporaryGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) AuthenticatorStream(ctx context.Context, opts ...grpc.CallOption) (V1_AuthenticatorStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_V1_serviceDesc.Streams[4], c.cc, "/MurmurRPC.V1/AuthenticatorStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &v1AuthenticatorStreamClient{stream}
	return x, nil
}

type V1_AuthenticatorStreamClient interface {
	Send(*Authenticator_Response) error
	Recv() (*Authenticator_Request, error)
	grpc.ClientStream
}

type v1AuthenticatorStreamClient struct {
	grpc.ClientStream
}

func (x *v1AuthenticatorStreamClient) Send(m *Authenticator_Response) error {
	return x.ClientStream.SendMsg(m)
}

func (x *v1AuthenticatorStreamClient) Recv() (*Authenticator_Request, error) {
	m := new(Authenticator_Request)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *v1Client) DatabaseUserQuery(ctx context.Context, in *DatabaseUser_Query, opts ...grpc.CallOption) (*DatabaseUser_List, error) {
	out := new(DatabaseUser_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/DatabaseUserQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) DatabaseUserGet(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error) {
	out := new(DatabaseUser)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/DatabaseUserGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) DatabaseUserUpdate(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/DatabaseUserUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) DatabaseUserRegister(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error) {
	out := new(DatabaseUser)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/DatabaseUserRegister", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) DatabaseUserDeregister(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/DatabaseUserDeregister", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) DatabaseUserVerify(ctx context.Context, in *DatabaseUser_Verify, opts ...grpc.CallOption) (*DatabaseUser, error) {
	out := new(DatabaseUser)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/DatabaseUserVerify", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) RedirectWhisperGroupAdd(ctx context.Context, in *RedirectWhisperGroup, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/RedirectWhisperGroupAdd", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) RedirectWhisperGroupRemove(ctx context.Context, in *RedirectWhisperGroup, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/RedirectWhisperGroupRemove", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for V1 service

type V1Server interface {
	// GetUptime returns murmur's uptime.
	GetUptime(context.Context, *Void) (*Uptime, error)
	// GetVersion returns murmur's version.
	GetVersion(context.Context, *Void) (*Version, error)
	// Events returns a stream of murmur events.
	Events(*Void, V1_EventsServer) error
	// ServerCreate creates a new virtual server. The returned server object
	// contains the newly created server's ID.
	ServerCreate(context.Context, *Void) (*Server, error)
	// ServerQuery returns a list of servers that match the given query.
	ServerQuery(context.Context, *Server_Query) (*Server_List, error)
	// ServerGet returns information about the given server.
	ServerGet(context.Context, *Server) (*Server, error)
	// ServerStart starts the given stopped server.
	ServerStart(context.Context, *Server) (*Void, error)
	// ServerStop stops the given virtual server.
	ServerStop(context.Context, *Server) (*Void, error)
	// ServerRemove removes the given virtual server and its configuration.
	ServerRemove(context.Context, *Server) (*Void, error)
	// ServerEvents returns a stream of events that happen on the given server.
	ServerEvents(*Server, V1_ServerEventsServer) error
	// ContextActionAdd adds a context action to the given user's client. The
	// following ContextAction fields must be set:
	//   context, action, text, and user.
	//
	// Added context actions are valid until:
	//  - The context action is removed with ContextActionRemove, or
	//  - The user disconnects from the server, or
	//  - The server stops.
	ContextActionAdd(context.Context, *ContextAction) (*Void, error)
	// ContextActionRemove removes a context action from the given user's client.
	// The following ContextAction must be set:
	//   action
	// If no user is given, the context action is removed from all users.
	ContextActionRemove(context.Context, *ContextAction) (*Void, error)
	// ContextActionEvents returns a stream of context action events that are
	// triggered by users.
	ContextActionEvents(*ContextAction, V1_ContextActionEventsServer) error
	// TextMessageSend sends the given TextMessage to the server.
	//
	// If no users, channels, or trees are added to the TextMessage, the message
	// will be broadcast the entire server. Otherwise, the message will be
	// targeted to the specified users, channels, and trees.
	TextMessageSend(context.Context, *TextMessage) (*Void, error)
	// TextMessageFilter filters text messages on a given server.
	TextMessageFilter(V1_TextMessageFilterServer) error
	// LogQuery returns a list of log entries from the given server.
	//
	// To get the total number of log entries, omit min and/or max from the
	// query.
	LogQuery(context.Context, *Log_Query) (*Log_List, error)
	// ConfigGet returns the explicitly set configuration for the given server.
	ConfigGet(context.Context, *Server) (*Config, error)
	// ConfigGetField returns the configuration value for the given key.
	ConfigGetField(context.Context, *Config_Field) (*Config_Field, error)
	// ConfigSetField sets the configuration value to the given value.
	ConfigSetField(context.Context, *Config_Field) (*Void, error)
	// ConfigGetDefault returns the default server configuration.
	ConfigGetDefault(context.Context, *Void) (*Config, error)
	// ChannelQuery returns a list of channels that match the given query.
	ChannelQuery(context.Context, *Channel_Query) (*Channel_List, error)
	// ChannelGet returns the channel with the given ID.
	ChannelGet(context.Context, *Channel) (*Channel, error)
	// ChannelAdd adds the channel to the given server. The parent and name of
	// the channel must be set.
	ChannelAdd(context.Context, *Channel) (*Channel, error)
	// ChannelRemove removes the given channel from the server.
	ChannelRemove(context.Context, *Channel) (*Void, error)
	// ChannelUpdate updates the given channel's attributes. Only the fields that
	// are set will be updated.
	ChannelUpdate(context.Context, *Channel) (*Channel, error)
	// UserQuery returns a list of connected users who match the given query.
	UserQuery(context.Context, *User_Query) (*User_List, error)
	// UserGet returns information on the connected user, given by the user's
	// session or name.
	UserGet(context.Context, *User) (*User, error)
	// UserUpdate changes the given user's state. Only the following fields can
	// be changed:
	//   name, mute, deaf, suppress, priority_speaker, channel, comment.
	UserUpdate(context.Context, *User) (*User, error)
	// UserKick kicks the user from the server.
	UserKick(context.Context, *User_Kick) (*Void, error)
	// TreeQuery returns a representation of the given server's channel/user
	// tree.
	TreeQuery(context.Context, *Tree_Query) (*Tree, error)
	// BansGet returns a list of bans for the given server.
	BansGet(context.Context, *Ban_Query) (*Ban_List, error)
	// BansSet replaces the server's ban list with the given list.
	BansSet(context.Context, *Ban_List) (*Void, error)
	// ACLGet returns the ACL for the given channel.
	ACLGet(context.Context, *Channel) (*ACL_List, error)
	// ACLSet overrides the ACL of the given channel to what is provided.
	ACLSet(context.Context, *ACL_List) (*Void, error)
	// ACLGetEffectivePermissions returns the effective permissions for the given
	// user in the given channel.
	ACLGetEffectivePermissions(context.Context, *ACL_Query) (*ACL, error)
	// ACLAddTemporaryGroup adds a user to a temporary group.
	ACLAddTemporaryGroup(context.Context, *ACL_TemporaryGroup) (*Void, error)
	// ACLRemoveTemporaryGroup removes a user from a temporary group.
	ACLRemoveTemporaryGroup(context.Context, *ACL_TemporaryGroup) (*Void, error)
	// AuthenticatorStream opens an authentication stream to the server.
	//
	// There can only be one RPC client with an open Stream. If a new
	// authenticator connects, the open connected will be closed.
	AuthenticatorStream(V1_AuthenticatorStreamServer) error
	// DatabaseUserQuery returns a list of registered users who match given
	// query.
	DatabaseUserQuery(context.Context, *DatabaseUser_Query) (*DatabaseUser_List, error)
	// DatabaseUserGet returns the database user with the given ID.
	DatabaseUserGet(context.Context, *DatabaseUser) (*DatabaseUser, error)
	// DatabaseUserUpdate updates the given database user.
	DatabaseUserUpdate(context.Context, *DatabaseUser) (*Void, error)
	// DatabaseUserRegister registers a user with the given information on the
	// server. The returned DatabaseUser will contain the newly registered user's
	// ID.
	DatabaseUserRegister(context.Context, *DatabaseUser) (*DatabaseUser, error)
	// DatabaseUserDeregister deregisters the given user.
	DatabaseUserDeregister(context.Context, *DatabaseUser) (*Void, error)
	// DatabaseUserVerify verifies the that the given user-password pair is
	// correct.
	DatabaseUserVerify(context.Context, *DatabaseUser_Verify) (*DatabaseUser, error)
	// AddRedirectWhisperGroup add a whisper targets redirection for the given
	// user. Whenever a user whispers to group "source", the whisper will be
	// redirected to group "target".
	RedirectWhisperGroupAdd(context.Context, *RedirectWhisperGroup) (*Void, error)
	// RemoveRedirectWhisperGroup removes a whisper target redirection for
	// the the given user.
	RedirectWhisperGroupRemove(context.Context, *RedirectWhisperGroup) (*Void, error)
}

func RegisterV1Server(s *grpc.Server, srv V1Server) {
	s.RegisterService(&_V1_serviceDesc, srv)
}

func _V1_GetUptime_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Void)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).GetUptime(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_GetVersion_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Void)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).GetVersion(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_Events_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Void)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(V1Server).Events(m, &v1EventsServer{stream})
}

type V1_EventsServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type v1EventsServer struct {
	grpc.ServerStream
}

func (x *v1EventsServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

func _V1_ServerCreate_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Void)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ServerCreate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ServerQuery_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Server_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ServerQuery(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ServerGet_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Server)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ServerGet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ServerStart_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Server)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ServerStart(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ServerStop_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Server)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ServerStop(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ServerRemove_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Server)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ServerRemove(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ServerEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Server)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(V1Server).ServerEvents(m, &v1ServerEventsServer{stream})
}

type V1_ServerEventsServer interface {
	Send(*Server_Event) error
	grpc.ServerStream
}

type v1ServerEventsServer struct {
	grpc.ServerStream
}

func (x *v1ServerEventsServer) Send(m *Server_Event) error {
	return x.ServerStream.SendMsg(m)
}

func _V1_ContextActionAdd_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ContextAction)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ContextActionAdd(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ContextActionRemove_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ContextAction)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ContextActionRemove(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ContextActionEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ContextAction)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(V1Server).ContextActionEvents(m, &v1ContextActionEventsServer{stream})
}

type V1_ContextActionEventsServer interface {
	Send(*ContextAction) error
	grpc.ServerStream
}

type v1ContextActionEventsServer struct {
	grpc.ServerStream
}

func (x *v1ContextActionEventsServer) Send(m *ContextAction) error {
	return x.ServerStream.SendMsg(m)
}

func _V1_TextMessageSend_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(TextMessage)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).TextMessageSend(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_TextMessageFilter_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(V1Server).TextMessageFilter(&v1TextMessageFilterServer{stream})
}

type V1_TextMessageFilterServer interface {
	Send(*TextMessage_Filter) error
	Recv() (*TextMessage_Filter, error)
	grpc.ServerStream
}

type v1TextMessageFilterServer struct {
	grpc.ServerStream
}

func (x *v1TextMessageFilterServer) Send(m *TextMessage_Filter) error {
	return x.ServerStream.SendMsg(m)
}

func (x *v1TextMessageFilterServer) Recv() (*TextMessage_Filter, error) {
	m := new(TextMessage_Filter)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _V1_LogQuery_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Log_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).LogQuery(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ConfigGet_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Server)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ConfigGet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ConfigGetField_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Config_Field)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ConfigGetField(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ConfigSetField_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Config_Field)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ConfigSetField(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ConfigGetDefault_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Void)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ConfigGetDefault(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ChannelQuery_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Channel_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ChannelQuery(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ChannelGet_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Channel)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ChannelGet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ChannelAdd_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Channel)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ChannelAdd(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ChannelRemove_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Channel)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ChannelRemove(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ChannelUpdate_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Channel)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ChannelUpdate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_UserQuery_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(User_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).UserQuery(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_UserGet_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(User)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).UserGet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_UserUpdate_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(User)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).UserUpdate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_UserKick_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(User_Kick)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).UserKick(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_TreeQuery_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Tree_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).TreeQuery(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_BansGet_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Ban_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).BansGet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_BansSet_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Ban_List)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).BansSet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ACLGet_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Channel)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ACLGet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ACLSet_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ACL_List)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ACLSet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ACLGetEffectivePermissions_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ACL_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ACLGetEffectivePermissions(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ACLAddTemporaryGroup_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ACL_TemporaryGroup)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ACLAddTemporaryGroup(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_ACLRemoveTemporaryGroup_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ACL_TemporaryGroup)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).ACLRemoveTemporaryGroup(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_AuthenticatorStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(V1Server).AuthenticatorStream(&v1AuthenticatorStreamServer{stream})
}

type V1_AuthenticatorStreamServer interface {
	Send(*Authenticator_Request) error
	Recv() (*Authenticator_Response, error)
	grpc.ServerStream
}

type v1AuthenticatorStreamServer struct {
	grpc.ServerStream
}

func (x *v1AuthenticatorStreamServer) Send(m *Authenticator_Request) error {
	return x.ServerStream.SendMsg(m)
}

func (x *v1AuthenticatorStreamServer) Recv() (*Authenticator_Response, error) {
	m := new(Authenticator_Response)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _V1_DatabaseUserQuery_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DatabaseUser_Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).DatabaseUserQuery(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_DatabaseUserGet_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DatabaseUser)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).DatabaseUserGet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_DatabaseUserUpdate_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DatabaseUser)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).DatabaseUserUpdate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_DatabaseUserRegister_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DatabaseUser)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).DatabaseUserRegister(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_DatabaseUserDeregister_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DatabaseUser)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).DatabaseUserDeregister(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_DatabaseUserVerify_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DatabaseUser_Verify)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).DatabaseUserVerify(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_RedirectWhisperGroupAdd_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RedirectWhisperGroup)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).RedirectWhisperGroupAdd(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _V1_RedirectWhisperGroupRemove_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RedirectWhisperGroup)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(V1Server).RedirectWhisperGroupRemove(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _V1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.V1",
	HandlerType: (*V1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUptime",
			Handler:    _V1_GetUptime_Handler,
		},
		{
			MethodName: "GetVersion",
			Handler:    _V1_GetVersion_Handler,
		},
		{
			MethodName: "ServerCreate",
			Handler:    _V1_ServerCreate_Handler,
		},
		{
			MethodName: "ServerQuery",
			Handler:    _V1_ServerQuery_Handler,
		},
		{
			MethodName: "ServerGet",
			Handler:    _V1_ServerGet_Handler,
		},
		{
			MethodName: "ServerStart",
			Handler:    _V1_ServerStart_Handler,
		},
		{
			MethodName: "ServerStop",
			Handler:    _V1_ServerStop_Handler,
		},
		{
			MethodName: "ServerRemove",
			Handler:    _V1_ServerRemove_Handler,
		},
		{
			MethodName: "ContextActionAdd",
			Handler:    _V1_ContextActionAdd_Handler,
		},
		{
			MethodName: "ContextActionRemove",
			Handler:    _V1_ContextActionRemove_Handler,
		},
		{
			MethodName: "TextMessageSend",
			Handler:    _V1_TextMessageSend_Handler,
		},
		{
			MethodName: "LogQuery",
			Handler:    _V1_LogQuery_Handler,
		},
		{
			MethodName: "ConfigGet",
			Handler:    _V1_ConfigGet_Handler,
		},
		{
			MethodName: "ConfigGetField",
			Handler:    _V1_ConfigGetField_Handler,
		},
		{
			MethodName: "ConfigSetField",
			Handler:    _V1_ConfigSetField_Handler,
		},
		{
			MethodName: "ConfigGetDefault",
			Handler:    _V1_ConfigGetDefault_Handler,
		},
		{
			MethodName: "ChannelQuery",
			Handler:    _V1_ChannelQuery_Handler,
		},
		{
			MethodName: "ChannelGet",
			Handler:    _V1_ChannelGet_Handler,
		},
		{
			MethodName: "ChannelAdd",
			Handler:    _V1_ChannelAdd_Handler,
		},
		{
			MethodName: "ChannelRemove",
			Handler:    _V1_ChannelRemove_Handler,
		},
		{
			MethodName: "ChannelUpdate",
			Handler:    _V1_ChannelUpdate_Handler,
		},
		{
			MethodName: "UserQuery",
			Handler:    _V1_UserQuery_Handler,
		},
		{
			MethodName: "UserGet",
			Handler:    _V1_UserGet_Handler,
		},
		{
			MethodName: "UserUpdate",
			Handler:    _V1_UserUpdate_Handler,
		},
		{
			MethodName: "UserKick",
			Handler:    _V1_UserKick_Handler,
		},
		{
			MethodName: "TreeQuery",
			Handler:    _V1_TreeQuery_Handler,
		},
		{
			MethodName: "BansGet",
			Handler:    _V1_BansGet_Handler,
		},
		{
			MethodName: "BansSet",
			Handler:    _V1_BansSet_Handler,
		},
		{
			MethodName: "ACLGet",
			Handler:    _V1_ACLGet_Handler,
		},
		{
			MethodName: "ACLSet",
			Handler:    _V1_ACLSet_Handler,
		},
		{
			MethodName: "ACLGetEffectivePermissions",
			Handler:    _V1_ACLGetEffectivePermissions_Handler,
		},
		{
			MethodName: "ACLAddTemporaryGroup",
			Handler:    _V1_ACLAddTemporaryGroup_Handler,
		},
		{
			MethodName: "ACLRemoveTemporaryGroup",
			Handler:    _V1_ACLRemoveTemporaryGroup_Handler,
		},
		{
			MethodName: "DatabaseUserQuery",
			Handler:    _V1_DatabaseUserQuery_Handler,
		},
		{
			MethodName: "DatabaseUserGet",
			Handler:    _V1_DatabaseUserGet_Handler,
		},
		{
			MethodName: "DatabaseUserUpdate",
			Handler:    _V1_DatabaseUserUpdate_Handler,
		},
		{
			MethodName: "DatabaseUserRegister",
			Handler:    _V1_DatabaseUserRegister_Handler,
		},
		{
			MethodName: "DatabaseUserDeregister",
			Handler:    _V1_DatabaseUserDeregister_Handler,
		},
		{
			MethodName: "DatabaseUserVerify",
			Handler:    _V1_DatabaseUserVerify_Handler,
		},
		{
			MethodName: "RedirectWhisperGroupAdd",
			Handler:    _V1_RedirectWhisperGroupAdd_Handler,
		},
		{
			MethodName: "RedirectWhisperGroupRemove",
			Handler:    _V1_RedirectWhisperGroupRemove_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Events",
			Handler:       _V1_Events_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ServerEvents",
			Handler:       _V1_ServerEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ContextActionEvents",
			Handler:       _V1_ContextActionEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TextMessageFilter",
			Handler:       _V1_TextMessageFilter_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "AuthenticatorStream",
			Handler:       _V1_AuthenticatorStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
}
